<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Assignments &raquo; A5: Sampling lights | CS
87/287 Rendering Algorithms</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark.css" />
  <link rel="stylesheet" href="m-documentation.css" />
  <link rel="icon" href="favicon.png" type="image/png" />
  <link rel="prev" href="assignment4.html" />
  <link rel="next" href="assignment6.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script><script src="jquery.event.move.js"></script><script src="jquery.twentytwenty.js"></script><link href="twentytwenty.css" rel="stylesheet" type="text/css" /><script>$(window).load(function(){$(".twentytwenty-container").twentytwenty({default_offset_pct: 0.5, move_slider_on_hover: true });});</script>
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://cs87-dartmouth.github.io/Fall2021"><img src="darts-logo.svg" alt="" />CS
87/287</a> <span class="m-breadcrumb">|</span> <a href="index.html" class="m-thin">Rendering Algorithms</a>
      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="schedule.html">Schedule</a></li>
            <li>
              <a href="assignments.html">Assignments</a>
              <ol>
                <li><a href="assignment0.html">A0: Darts preliminaries</a></li>
                <li><a href="assignment1.html">A1: Ray tracing</a></li>
                <li><a href="assignment2.html">A2: Ray tracing faster</a></li>
                <li><a href="assignment3.html">A3: Textures</a></li>
                <li><a href="assignment4.html">A4: Sampling materials</a></li>
                <li><a href="assignment5.html" id="m-navbar-current">A5: Sampling lights</a></li>
                <li><a href="assignment6.html">A6: Final project</a></li>
              </ol>
            </li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li>
              <a href="darts-overview.html">Code</a>
              <ol>
                <li><a href="darts-overview.html">Darts</a></li>
                <li><a href="getting-started.html">Getting started</a></li>
                <li><a href="https://github.com/cs87-dartmouth/Fall2021">GitHub</a></li>
                <li><a href="modules.html">Modules</a></li>
                <li><a href="annotated.html">Classes</a></li>
                <li><a href="files.html">Files</a></li>
              </ol>
            </li>
            <li><a href="credits.html">Credits</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="assignments.html">Assignments</a> &raquo;</span>
          A5: Sampling lights
        </h1>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              <a href="#autotoc_md90">Task 1: Sampling Geometry</a>
              <ul>
                <li><a href="#autotoc_md91">Triangles</a></li>
                <li><a href="#autotoc_md92">Spherical Cap</a></li>
              </ul>
            </li>
            <li>
              <a href="#autotoc_md93">Task 2: Making Lights Sampleable</a>
              <ul>
                <li><a href="#autotoc_md94">Rectangles</a></li>
                <li><a href="#autotoc_md95">Triangles</a></li>
                <li><a href="#autotoc_md96">Spheres</a></li>
                <li><a href="#autotoc_md97">Surface Groups</a></li>
              </ul>
            </li>
            <li>
              <a href="#autotoc_md98">Task 3: Integrating Lights</a>
              <ul>
                <li><a href="#autotoc_md99">Direct Lighting Material Integrator</a></li>
                <li><a href="#autotoc_md100">Creating a list of scene emitters</a></li>
                <li>
                  <a href="#autotoc_md101">Next Event Integrator</a>
                  <ul>
                    <li><a href="#autotoc_md102">Additional verification</a></li>
                  </ul>
                </li>
                <li><a href="#autotoc_md103">MIS Integrator</a></li>
                <li><a href="#autotoc_md104">Full Path Tracing</a></li>
              </ul>
            </li>
            <li><a href="#autotoc_md105">What to submit</a></li>
          </ul>
        </div>
<aside class="m-note m-danger"><h3>Note</h3><p>Make sure to do a <code>git pull upstream main</code> to retrieve any updates to the base code before you begin!</p></aside><p>In this final assignment, you will use the sampling and integrator interfaces from the previous assignment to build powerful new integrators that can handle lights with much less noise than you&#x27;ve seen so far.</p><p>This assignment consists of three parts. In the first, you will implement sampling routines for different geometries, and visualize the resulting points. Then you will modify the existing shapes in darts to allow sampling them and evaluate their PDFs. Finally, you will implement new integrators that make use of the ability to sample emissive geometry in the scene.</p><section id="autotoc_md90"><h2><a href="#autotoc_md90">Task 1: Sampling Geometry</a></h2><p>In this part, you will implement (in <code><a href="sampling_8h.html" class="m-doc">include/<wbr />darts/<wbr />sampling.h</a></code>) a few new functions for sampling basic geometry, which will make the later parts of the assignment easier. Similar to last time, you should write a standalone program to generate and save a few hundred points from your functions, and visualize them using your favorite plotting tool (we will show screenshots from <a href="https://chart-studio.plot.ly/create/#/">plot.ly</a>). You can reuse the same program you used in the previous assignment.</p><section id="autotoc_md91"><h3><a href="#autotoc_md91">Triangles</a></h3><div class="m-col-s-6 m-col-m-5 m-right-s"><img class="m-image" src="images/triangle-points.png" alt="Image" /></div><p>Implement a function <code>sample_triangle()</code> that produces points uniformly at random on a triangle with the specified coordinates. There are different ways you can do this; the easiest way is to first generate random barycentric coordinates (alpha, beta, gamma), and then return the corresponding interpolated point <code>v0*alpha + v1*beta + v2*gamma</code>.</p><div class="m-clearfix-s"></div><div class="m-clearfix-m"></div><div class="m-clearfix-l"></div><aside class="m-block m-success"><h3>Hint</h3><p>You can generate random barycentric coordinates by computing <code>alpha</code> and <code>beta</code> uniformly at random in [0,1], and set <code>gamma = 1 - alpha - beta</code>. However, if <code>alpha+beta&gt;1</code>, this will give you an invalid coordinate for <code>gamma</code>. An easy fix is to flip the coordinates (i.e. set <code>alpha = 1 - alpha</code>, <code>beta = 1 - beta</code>) if <code>alpha+beta&gt;1</code>.</p></aside><p>Also implement the corresponding <code>sample_triangle_pdf()</code> function.</p><p>Visualize points from your function for a triangle with corners (0,0,0), (1,1,1) and (0.5, 1, 2). You should get points like the ones shown in the image here.</p></section><section id="autotoc_md92"><h3><a href="#autotoc_md92">Spherical Cap</a></h3><div class="m-col-s-6 m-col-m-5 m-right-s"><img class="m-image" src="spherical-cap-points.png" alt="Image" /></div><p>Now implement the function <code>sample_sphere_cap()</code> to sample points uniformly at random from a spherical cap. You&#x27;ve already (implicitly) implemented this method for your previous assignment: Sampling the sphere and the hemisphere are just special cases of sampling different sections of the sphere. Copy-paste the code for sampling the hemisphere from your previous assignment; all that needs to change is the computation of <code>cos_theta</code>: It should be distributed uniformly between 1 and <code>cos_theta_max</code>; this is the cosine of the largest angle that points are allowed to have with the normal. In pseudo code, <code>cos_theta = lerp(cos_theta_max, 1.0f, &lt;uniform random number&gt;)</code>.</p><p>Also implement the corresponding <code>sample_sphere_cap_pdf()</code> function.</p><p>Visualize your code for an angle of pi/4 (Hint: You pass the cosine of the angle to this function, not the angle directly). It should look something like the image shown here.</p></section></section><section id="autotoc_md93"><h2><a href="#autotoc_md93">Task 2: Making Lights Sampleable</a></h2><p>In this task, you will extend the surface base class in darts with a new sampling interface. Open <code><a href="surface_8h.html" class="m-doc">surface.h</a></code>. You should see a new struct <code>EmitterRecord</code>, and three new methods: <code>Surface::sample()</code>, <code>Surface::pdf()</code>, and <code>Surface::is_emissive()</code>. Read their documentation.</p><p><code>Surface::sample()</code> will generate a random <em>direction</em> that points from <code>rec.o</code> towards the surface. The direction is guaranteed to hit the surface from <code>rec.o</code>. Usually, you will do this by first generating a point on the surface (using the functions from Task 1) and then computing the direction from <code>rec.o</code> to the point. However, for certain shapes (like the sphere), we will sample directions directly.</p><p><code>Surface::pdf()</code> will return the probability density of generating a certain direction <code>v</code>, seen from point <code>o</code>. Usually, you would implement this by tracing a ray from <code>o</code> in direction <code>v</code> and checking if it hits the surface (and returning 0 if not - we never generate directions not towards the surface); the PDF is then the PDF of generating the hitpoint (usually 1/surface area) times the geometry factor (squared distance to <code>o</code> divided by the cosine of <code>v</code> with the surface normal at the hit point).</p><p>Similar to last assignment, we provide a new set of tests for your sampling code. The implementation is available in <code>src/tests/surface_sample_test.cpp</code>. Add it to your project by modifying the <code>CMakeLists.txt</code> file like you did in the previous assignment.</p><section id="autotoc_md94"><h3><a href="#autotoc_md94">Rectangles</a></h3><p>To help you get started with sampling surfaces, we provide working implementations of <code>Quad::sample()</code> and <code>Quad::pdf()</code> in <code><a href="quad_8cpp.html" class="m-doc">quad.cpp</a></code>.</p><p><code>Quad::sample()</code>, generates a random point on the rectangle, stores it in <code>rec.hit.p</code>, and computes the normalized direction from <code>rec.o</code> to this point, along with the PDF and other members of the <code>EmitterRecord</code>. It then returns the emitted color of that surface point divided by the PDF.</p><aside class="m-block m-success"><h3>Note</h3><p>You can get the vectors for the two sides of the rectangle using</p><pre>v0 = m_xform.vector({m_size.x, 0, 0})  
v1 = m_xform.vector({0, m_size.y, 0})
</pre></aside><p><code>Quad::pdf()</code>, checks if the given direction hits the <a href="class_quad.html" class="m-doc">Quad</a> from the given origin <code>o</code>. If not, it returns 0; otherwise, it returns 1/area times the geometry factor.</p><aside class="m-block m-success"><h3>Note</h3><p>The length of the cross product of <code>v0</code> and <code>v1</code> is exactly 1/4th of the surface area.</p></aside><p>You can test this code using the sample tester tool by running:</p><pre class="m-code">darts scenes/assignment5/test_surfaces.json</pre><p>You should get images like these for <code>quad-pdf.png</code> and <code>quad-sampled.png</code>:</p><div class="twentytwenty-container"><img class="m-image" src="quad-pdf-ref.png" alt="Analytic distribution" />
 <img class="m-image" src="quad-sampled-ref.png" alt="Observed distribution" /></div></section><section id="autotoc_md95"><h3><a href="#autotoc_md95">Triangles</a></h3><p>Now add and implement <code>Triangle::sample()</code> and <code>Triangle::pdf()</code> (we&#x27;ve already implemented <code>Triangle::is_emissive()</code> for you). Use exactly the same recipe as you did for the quad - all that needs to change is how to get a point on the surface, and the computation of the surface area. Look at <code>Triangle::intersect()</code> for inspiration for how to get the three corners of the triangle (<code>p0</code>, <code>p1</code> and <code>p2</code>).</p><aside class="m-block m-success"><h3>Hint</h3><p>The length of the cross product of any two sides of the triangle is twice the triangle&#x27;s area.</p></aside><div class="twentytwenty-container"><img class="m-image" src="triangle-pdf-ref.png" alt="Analytic distribution" />
 <img class="m-image" src="triangle-sampled-ref.png" alt="Observed distribution" /></div></section><section id="autotoc_md96"><h3><a href="#autotoc_md96">Spheres</a></h3><p>Open <code><a href="sphere_8h.html" class="m-doc">sphere.h</a></code> and <code><a href="sphere_8cpp.html" class="m-doc">sphere.cpp</a></code>, and add and implement <code>Sphere::sample()</code> and <code>Sphere::pdf()</code> (we already provide you <code>XformedSurfaceWithMaterial::is_emissive()</code>, which <code><a href="class_sphere.html" class="m-doc">Sphere</a></code> inherits).</p><p>We will use a different approach for sampling the sphere: Instead of sampling a point on the sphere first and computing the direction towards it, we will directly sample the cone of directions that all point towards the sphere. To do this, you can use your function for sampling spherical caps from the first task. However, to use this function you need to first figure out <code>cos_theta_max</code>, the angular extent of the sphere as seen from <code>rec.o</code>. You can compute it with <code>cos_theta_max = sqrt(d*d - r*r)/d</code> where <code>d</code> is the distance from the center of sphere to <code>rec.o</code>, and <code>r</code> is the radius of the sphere. Hint: Can this formula fail? When does this happen? What should the value of <code>cos_theta_max</code> be in that case? Note that the sphere may be transformed by a <code><a href="struct_transform.html" class="m-doc">Transform</a></code>, so <code>r</code> may not simply be <code><a href="class_sphere.html#a1faee6c9b6e62abf0d35cc87a1894b61" class="m-doc">Sphere::<wbr />m_radius</a></code>. You may assume that the <code><a href="struct_transform.html" class="m-doc">Transform</a></code> contains only isotropic scaling and rotation. How can you compute the resulting radius in that case?</p><p>The sampling function you implemented in Task 1 assumes the spherical cap is aligned with the z axis. You should use your <code>ONB</code> class to transform the sampled direction, so that the spherical cap points from <code>rec.o</code> towards the center of the sphere instead.</p><p>For <code>Sphere::pdf()</code>, you should first check if the ray with the given origin/direction intersects with the sphere. If it does, the PDF is simply 1/solid angle of the spherical cap (no geometry factor needed - we generated directions directly!). The solid angle of a spherical cap with opening angle of <code>theta_max</code> is <code>2*pi*(1-cos(theta_max))</code>.</p><p>Test your code with the sample tester tool by running the scene <code>scenes/assignment5/test_surfaces.json</code> again. You should get images like these:</p><div class="twentytwenty-container"><img class="m-image" src="sphere-pdf-ref.png" alt="Analytic distribution" />
 <img class="m-image" src="sphere-sampled-ref.png" alt="Observed distribution" /></div></section><section id="autotoc_md97"><h3><a href="#autotoc_md97">Surface Groups</a></h3><p>Open <code><a href="surface__group_8h.html" class="m-doc">surface_<wbr />group.h</a></code> and <code><a href="surface__group_8cpp.html" class="m-doc">surface_<wbr />group.cpp</a></code> and implement the sampling interface for the <code><a href="class_surface_group.html" class="m-doc">SurfaceGroup</a></code> class. This class represents a collection of shapes (e.g. the list of all lights in the scene), which are stored in the array <code>m_surfaces</code>. For <code>SurfaceGroup::sample()</code>, you should randomly generate an integer index in range <code>0...m_surfaces.size() - 1</code> (inclusive) and call the <code>sample()</code> method of the surface at that index in the array. For <code>pdf()</code>, you should call the <code>pdf()</code> method of each surface in the list, and return the average of all the PDF evaluations. Hint: You can use the following syntax to iterate over all shapes:</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">surface</span> <span class="p">:</span> <span class="n">m_surfaces</span><span class="p">)</span>  
    <span class="n">surface</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span></pre><p>Test your code with the sample tester tool by running the scene <code>scenes/assignment5/test_surfaces.json</code> again. You should get images like these:</p><div class="twentytwenty-container"><img class="m-image" src="group-pdf-ref.png" alt="Analytic distribution" />
 <img class="m-image" src="group-sampled-ref.png" alt="Observed distribution" /></div></section></section><section id="autotoc_md98"><h2><a href="#autotoc_md98">Task 3: Integrating Lights</a></h2><p>In this task, we will implement better integrators for direct lighting. You&#x27;ll use the sampling interfaces you implemented in the earlier task to explicitly guide rays towards light sources.</p><p>Note that the algorithm described in this assignment is slightly different from the pseudo-code shown in class: Both algorithms will work, and you are free to implement either version, as long as it gives you the correct image.</p><p>We will begin by focusing on direct lighting, and then slowly extend our integrators to account for global illumination.</p><section id="autotoc_md99"><h3><a href="#autotoc_md99">Direct Lighting Material Integrator</a></h3><div class="m-col-s-6 m-col-m-5 m-right-s"><a href="veach_mats-ref.png"><img class="m-image" src="veach_mats-ref.png" alt="Image" /></a></div><p>First make sure your <code>PathTracerMats</code> integrator from the last assignment can successfully render <code>scenes/assignment4/veach_mats.json</code> to produce a direct illumination image like the one shown here when &lsquo;&quot;max_bounces&quot;&rsquo; is set to 1.</p><p>Most of this image looks extremely noisy, especially the background and the reflections in the lower right. We can do better than this!</p></section><section id="autotoc_md100"><h3><a href="#autotoc_md100">Creating a list of scene emitters</a></h3><p>Instead of asking the <code><a href="class_material.html" class="m-doc">Material</a></code> to generate ray directions for us, we could instead generate ray directions by sampling points on all surfaces in the scene using our new <code>Surface::sample()</code> function. As it is now, however, this would not be so useful, since most surfaces in the scene do not emit light. We&#x27;d like to sample rays towards surfaces that emit light. To do that we first need to add some plumbing to our code to allow a <code><a href="class_scene.html" class="m-doc">Scene</a></code> to maintain a list of only the emissive surfaces.</p></section><section id="autotoc_md101"><h3><a href="#autotoc_md101">Next Event Integrator</a></h3><p>Add a new integrator class called <code>PathTracerNEE</code>, and register it with the factory using the string <code>&quot;path_tracer_nee&quot;</code>. The &quot;NEE&quot; part stands for <em>Next Event Estimation</em>, which is a fancy name for sampling light sources directly. We will start by implementing direct lighting with no recursion first.</p><div class="m-col-s-6 m-col-m-5 m-right-s"><a href="veach_nee-ref.png"><img class="m-image" src="veach_nee-ref.png" alt="Image" /></a></div><p>On a basic level, this integrator looks very similar to the material-based integrator from the previous subtask (and you can start by copy-pasting that code and removing the recursion). However, instead of calling <code>Material::sample()</code> to produce a direction, it should call <code>scene.emitters().sample()</code>. <code>scene.emitters()</code> is a <code><a href="class_surface_group.html" class="m-doc">SurfaceGroup</a></code> that contains all emissive shapes in the scene. Similarly, instead of dividing by <code>Material::pdf()</code>, you should divide by <code>scene.emitters().pdf()</code>.</p><p>This (for the first time) shows the flexibility of the Monte Carlo approach: All you had to change was the sampling and PDF routine, and you get a noise-free image much faster! This would not have been possible with the renderer you wrote in Assignment 1. Convince yourself that this integrator has much less noise by running your new code on <code>scenes/assignment5/veach_nee.json</code>. You should get an image looking like the one shown here.</p><p>This looks <em>much</em> better than the <code>PathTracerMats</code> integrator for most of the image... except for the upper left, where the NEE estimator does much worse. Just like discussed in class, we&#x27;ll fix this by combining both estimators with MIS in the next section. Also beware that this new estimator will not (yet) work correctly if you set <code>&quot;max_bounces&quot;</code> &gt; 1. We&#x27;ll handle that further in this assignment.</p><section id="autotoc_md102"><h4><a href="#autotoc_md102">Additional verification</a></h4><p>But before we do, we&#x27;ve designed a few more scenes to help you debug and verify your implementation.</p><p>If the Veach scene isn&#x27;t rendering correctly, it can be difficult to isolate the issue because it tests multiple features simultaneously. We provide a simpler set of scenes to help you debug your sphere lights and integrators. They are <code>scenes/assignment5/sphere_light_[small|medium|large]_XXX.json</code>. These scenes rely on the principle that two fully visible sphere lights will produce identical illumination on a diffuse surface even if their radii are different, as long as their power is the same.</p><div class="twentytwenty-container"><img class="m-image" src="sphere_light_small_mis-ref.png" alt="Small light" />
 <img class="m-image" src="sphere_light_medium_mis-ref.png" alt="Medium light" />
 <img class="m-image" src="sphere_light_large_mis-ref.png" alt="Large light" /></div><p>The Veach scene uses sphere lights, but let&#x27;s also test triangle lights. Render the <code>scenes/assignment5/odyssey_triangle_mats.json</code> and <code>scenes/assignment5/odyssey_triangle_nee.json</code> and scenes. This scene is identical to the one from the previous assignment, but the rectangular light source is composed of two <code>Triangle</code>s instead of a single <code><a href="class_quad.html" class="m-doc">Quad</a></code>. Compare these triangle versions to the quad versions in <code>scenes/assignment4/odyssey_mats.json</code> and <code>scenes/assignment5/odyssey_nee.json</code>.</p><div class="twentytwenty-container"><img class="m-image" src="odyssey_mats-ref.png" alt="Material sampling one quad" />
 <img class="m-image" src="odyssey_triangle_mats-ref.png" alt="Material sampling two triangles" />
 <img class="m-image" src="odyssey_nee-ref.png" alt="Light sampling one quad" />
 <img class="m-image" src="odyssey_triangle_nee-ref.png" alt="Light sampling two triangles" /></div></section></section><section id="autotoc_md103"><h3><a href="#autotoc_md103">MIS Integrator</a></h3><p>Add a new integrator class called <code>PathTracerMIS</code>, and register it with the factory using the string <code>&quot;path_tracer_mis&quot;</code>. The MIS part stands for&nbsp;<em>Multiple Importance Sampling</em>, which is a technique for efficiently combining multiple integration techniques.</p><p>Begin by copy-pasting either your <code>PathTracerMats</code> or your <code>PathTracerNEE</code> integrator from before. Instead of always sampling from the material, or always from the light source, you should sample from a <em>mixture</em> of both of them. With probability of 0.5, generate a direction by sampling the material; otherwise, generate a direction by sampling the lights. After you&#x27;ve generated a direction, trace a ray and evaluate the emission and material like before; however, instead of dividing by just the material pdf or the light PDF, divide by the&nbsp;<em>average</em> of the two PDFs (since you randomly sample from either one).</p><p>Test your integrator on <code>scenes/assignment5/veach_mis.json</code> and compare to the NEE and material sampling variants. You should get images like those below:</p><div class="twentytwenty-container"><img class="m-image" src="veach_mats-ref.png" alt="Material sampling" />
 <img class="m-image" src="veach_nee-ref.png" alt="Next event estimation" />
 <img class="m-image" src="veach_mis-ref.png" alt="MIS" /></div><p>The integrator now works robustly in all parts of the scene, and combines the good traits of both material sampling and light sampling.</p><p>Also test your integrators on <code>scenes/assignment5/odyssey_triangle_XXX.json</code>. Here is our comparison:</p><div class="twentytwenty-container"><img class="m-image" src="odyssey_triangle_mats-ref.png" alt="Material sampling" />
 <img class="m-image" src="odyssey_triangle_nee-ref.png" alt="Next event estimation" />
 <img class="m-image" src="odyssey_triangle_mis-ref.png" alt="MIS" /></div></section><section id="autotoc_md104"><h3><a href="#autotoc_md104">Full Path Tracing</a></h3><p>Now extend the <code>PathTracerMIS</code> integrator from the previous subtask to do not just direct lighting, but all direct and indirect lighting. Your code currently finds the closest hit point along the given ray, estimates direct lighting at that location and exits. All you need to do in order to support indirect light is to add recursion before exiting: After computing direct lighting, sample the material to obtain the next ray along the path, and call the function recursively with the new ray to obtain an estimate of indirect lighting. Divide that estimate by the material sampling PDF, and add this estimate to the direct lighting estimate. That&#x27;s it!</p><p><strong>Optional</strong>: You could complete your <code>PathTracerNEE</code> integrator to compute full global illumination in exactly the same way. Just generate a recursive ray by sampling the material in addition to the (non-recursive) shadow ray towards the lights.</p><p><strong>Grad Students: Optimize your PathTracerMIS integrator</strong>. In the current version, you sample the material and trace a ray once for direct lighting, and a second time for the recursive ray. This is wasteful - they can both use the same ray and intersection (intersecting the scene is expensive!). Optimize your implementation to reuse the material ray and intersection for the recursive call. You can check the lecture slides for ideas on how to do this.</p><aside class="m-block m-success"><h3>Hint</h3><p>With the randomized MIS approach, you only sample the material 50% of the time, so you don&#x27;t always have that ray available. You can simplify it by removing randomness and always taking one light sample and one material sample, and averaging the direct light estimates from both. Then, reuse the ray and intersection sampled from the material for the recursive call.</p></aside><p>Test your new integrators on <code>scenes/assignment5/jensen_box_XXX.json</code>.</p><div class="twentytwenty-container"><img class="m-image" src="jensen_box_mats-ref.png" alt="Material sampling" />
 <img class="m-image" src="jensen_box_nee-ref.png" alt="Next event estimation" />
 <img class="m-image" src="jensen_box_mis-ref.png" alt="MIS" /></div></section></section><section id="autotoc_md105"><h2><a href="#autotoc_md105">What to submit</a></h2><p>In your report, make sure to include:</p><ul><li>Visualized point sets for all distributions from task 1</li><li>Rendered images of all the scenes in <code>scenes/assignment5</code></li></ul><p>Then submit according to the instructions in the <a href="getting-started.html#submitting-on-canvas" class="m-doc">Submitting on Canvas</a> section of <a href="getting-started.html" class="m-doc">Getting started</a> guide.</p></section>
        <div class="m-note m-dim m-thin m-text-center"><a href="assignment4.html" class="m-doc">&laquo; A4: Sampling materials</a> | <a href="assignments.html" class="m-doc">Assignments</a> | <a href="assignment6.html" class="m-doc">A6: Final project &raquo;</a></div>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v1.js"></script>
<script src="searchdata-v1.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>CS 87/287 Rendering Algorithms. Created with <a href="https://doxygen.org/">Doxygen</a> 1.9.1 and <a href="https://mcss.mosra.cz/">m.css</a>.<br />See <a href="credits.html">credits page</a> for additional acknowledgements.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
