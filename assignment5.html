<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Assignments &raquo; A5: Sampling lights | CS
87/287 Rendering Algorithms</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark.css" />
  <link rel="stylesheet" href="m-documentation.css" />
  <link rel="icon" href="favicon-dark.png" type="image/png" />
  <link rel="prev" href="assignment4.html" />
  <link rel="next" href="assignment6.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script><script src="jquery.event.move.js"></script><script src="jquery.twentytwenty.js"></script><link href="twentytwenty.css" rel="stylesheet" type="text/css" /><script>$(window).load(function(){$(".twentytwenty-container").twentytwenty({default_offset_pct: 0.5, move_slider_on_hover: true });});</script>
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://cs87-dartmouth.github.io/Fall2021"><img src="darts-logo.svg" alt="" />CS
87/287</a> <span class="m-breadcrumb">|</span> <a href="index.html" class="m-thin">Rendering Algorithms</a>
      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li>
              <a href="assignments.html">Assignments</a>
              <ol>
                <li><a href="assignment0.html">A0: Darts preliminaries</a></li>
                <li><a href="assignment1.html">A1: Ray tracing</a></li>
                <li><a href="assignment2.html">A2: Ray tracing faster</a></li>
                <li><a href="assignment3.html">A3: Textures</a></li>
                <li><a href="assignment4.html">A4: Sampling materials</a></li>
                <li><a href="assignment5.html" id="m-navbar-current">A5: Sampling lights</a></li>
                <li><a href="assignment6.html">A6: Final project</a></li>
              </ol>
            </li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="2">
            <li>
              <a href="darts-overview.html">Code</a>
              <ol>
                <li><a href="darts-overview.html">Code</a></li>
                <li><a href="getting-started.html">Getting started</a></li>
                <li><a href="modules.html">Modules</a></li>
                <li><a href="annotated.html">Classes</a></li>
                <li><a href="files.html">Files</a></li>
              </ol>
            </li>
            <li><a href="credits.html">Credits</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="assignments.html">Assignments</a> &raquo;</span>
          A5: Sampling lights
        </h1>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              <a href="#autotoc_md87">Task 1: Sampling Geometry</a>
              <ul>
                <li><a href="#autotoc_md88">Spheres</a></li>
                <li><a href="#autotoc_md89">Rectangles</a></li>
                <li><a href="#autotoc_md90">Triangles</a></li>
                <li><a href="#autotoc_md91">Spherical Cap</a></li>
              </ul>
            </li>
            <li>
              <a href="#autotoc_md92">Task 2: Making Lights Samplable</a>
              <ul>
                <li><a href="#autotoc_md93">Rectangles</a></li>
                <li><a href="#autotoc_md94">Triangles</a></li>
                <li><a href="#autotoc_md95">Spheres</a></li>
                <li><a href="#autotoc_md96">Surface Groups</a></li>
              </ul>
            </li>
            <li>
              <a href="#autotoc_md97">Task 3: Integrating Lights</a>
              <ul>
                <li><a href="#autotoc_md98">Direct Lighting Material Integrator</a></li>
                <li><a href="#autotoc_md99">Creating a list of scene emitters</a></li>
                <li><a href="#autotoc_md100">Next Event Integrator</a></li>
                <li><a href="#autotoc_md101">MIS Integrator</a></li>
                <li><a href="#autotoc_md102">Full Path Tracing</a></li>
              </ul>
            </li>
            <li><a href="#autotoc_md103">What to submit</a></li>
          </ul>
        </div>
<aside class="m-note m-danger"><h3>Note</h3><p>Make sure to do a <code>git pull upstream remote</code> to retrieve any updates to the base code before you begin!</p></aside><p>In this final assignment, you will use the sampling and integrator interfaces from the previous assignment to build powerful new integrators that can handle lights with much less noise than you&#x27;ve seen so far.</p><p>This assignment consists of three parts. In the first, you will implement sampling routines for different geometries, and visualize the resulting points. Then you will modify the existing shapes in darts to allow sampling them and evaluate their PDFs. Finally, you will implement new integrators that make use of the ability to sample emissive geometry in the scene.</p><section id="autotoc_md87"><h2><a href="#autotoc_md87">Task 1: Sampling Geometry</a></h2><p><span class="m-label m-primary m-flat">3 pts</span></p><p>In this part, you will implement new functions for sampling basic geometry, which will make the later parts of the assignment easier. Similar to last time, you should write a standalone program to generate and save a few hundred points from your function, and visualize them using your favourite plotting tool (we will show screenshots from <a href="https://chart-studio.plot.ly/create/#/">plot.ly</a>). You can reuse the same program you used in the previous assignment.</p><section id="autotoc_md88"><h3><a href="#autotoc_md88">Spheres</a></h3><div class="m-col-s-6 m-col-m-5 m-right-s"><img class="m-image" src="sphere-points.png" alt="Image" /></div><p>As a warm-up, begin by implementing a <code>Vec3f sampleSphere(Vec3f center, float radius)</code> function that samples a point on a sphere with the given center and radius. You can use your <code>randomOnUnitSphere()</code> function from the previous assignment; all you need to do is scale and offset the points from this function.</p><p>Visualize the points you get for a sphere with center (0.5, 1, 2) and radius 3. It should look something like the image shown here.</p><div class="m-clearfix-s"></div><div class="m-clearfix-m"></div><div class="m-clearfix-l"></div></section><section id="autotoc_md89"><h3><a href="#autotoc_md89">Rectangles</a></h3><div class="m-col-s-6 m-col-m-5 m-left-s"><img class="m-image" src="quad-points.png" alt="Image" /></div><p>Implement a function <code>sampleRect(Vec3f center, Vec3f v0, Vec3f v1)</code> that produces random points on a rectangle with corners <code>center ± v0 ± v1.</code></p><div class="m-clearfix-s"></div><div class="m-clearfix-m"></div><div class="m-clearfix-l"></div><aside class="m-block m-success"><h3>Hint</h3><p>All points on this rectangle can be parametrized by <code>center + a*v0 + b*v1</code>, where <code>a</code> and <code>b</code> range from -1 to 1. Generate random <code>a</code> and <code>b</code> in this range and use this formula to turn them into points on the rectangle.</p></aside><p>Visualize the points from this function for a center of (0, 1, 0) and sides (1, 0, 0), (0, 1, 0.6). You should get a point set like the one shown in the image here.</p></section><section id="autotoc_md90"><h3><a href="#autotoc_md90">Triangles</a></h3><div class="m-col-s-6 m-col-m-5 m-right-s"><img class="m-image" src="triangle-points.png" alt="Image" /></div><p>Implement a function <code>sampleTriangle(Vec3f v0, Vec3f v1, Vec3f v2)</code> that produces points uniformly at random on a triangle with the specified coordinates. There are different ways you can do this; the easiest way is to first generate random barycentric coordinates (a, b, c), and then return the corresponding interpolated point <code>v0*a + v1*b + v2*c</code>.</p><div class="m-clearfix-s"></div><div class="m-clearfix-m"></div><div class="m-clearfix-l"></div><aside class="m-block m-success"><h3>Hint</h3><p>You can generate random barycentric coordinates by computing <code>a</code> and <code>b</code> uniformly at random in [0,1], and set <code>c = 1 - a - b</code>. However, if <code>a+b&gt;1</code>, this will give you an invalid coordinate for <code>c</code>. You can either do rejection sampling and repeat this procedure until you get valid coordinates, or you can flip the coordinates (i.e. set <code>a = 1 - a</code>, <code>b = 1 - b</code>) if <code>a+b</code> is greater than 1.</p></aside><p>Visualize points from your function for a triangle with corners (0,0,0), (1,1,1) and (0.5, 1, 2). You should get points like the ones shown in the image here.</p></section><section id="autotoc_md91"><h3><a href="#autotoc_md91">Spherical Cap</a></h3><div class="m-col-s-6 m-col-m-5 m-right-s"><img class="m-image" src="spherical-cap-points.png" alt="Image" /></div><p>Finally, add a method <code>randomSphericalCap(float cos_theta_max)</code> for sampling points uniformly at random from a spherical cap. You&#x27;ve already (implicitly) implemented this method for your previous assignment: Sampling the sphere and the hemisphere are just special cases of sampling different sections of the sphere. Copy-paste the code for sampling the hemisphere from your previous assignment; all that needs to change is the computation of cosTheta: It should be distributed uniformly between 1 and <code>cos_theta_max</code>; this is the cosine of the largest angle points are allowed to have with the normal. In pseudo code, <code>cosTheta = lerp(cos_theta_max, 1.0f, randf())</code>.</p><p>Visualize your code for an angle of pi/4 (hint: You pass the cosine of the angle to this function, not the angle directly). It should look something like the image shown here.</p></section></section><section id="autotoc_md92"><h2><a href="#autotoc_md92">Task 2: Making Lights Samplable</a></h2><p><span class="m-label m-primary m-flat">5 pts</span></p><p>In this task, you will extend the surface base class in darts with a new sampling interface. Open <code>surface.h</code> and add two new methods to <code>Surface</code>:</p><div class="m-col-s-10 m-col-m-9 m-center-s"><img class="m-image" src="sampling-interface.png" alt="Image" /></div><p><code>Surface::sample()</code> will generate a random <em>direction</em> that points from <code>o</code> towards the surface. The direction is guaranteed to hit the surface from <code>o</code>. Usually, you will do this by first generating a point on the surface (using the functions from task 1) and then computing the direction from <code>o</code> to the point. However, for certain shapes (like the sphere), we will sample directions directly.</p><p><code>Surface::pdf()</code> will return the probability density of generating a certain direction <code>v</code>, seen from point <code>o</code>. Usually, you would implement this by tracing a ray from <code>o</code> in direction <code>v</code> and checking if it hits the surface (and returning 0 if not - we never generate directions not towards the surface); the PDF is then the PDF of generating the hitpoint (usually 1/surface area) times the geometry factor (squared distance to <code>o</code> divided by the cosine of <code>v</code> with the surface normal at the hit point).</p><p>Similar to last assignment, we provide an updated tool for testing your sampling code. This is in <code>src/04_sample_test.cpp</code>. Add it to your project by modifying the <code>CMakeLists.txt</code> file like you did in the previous assignment.</p><section id="autotoc_md93"><h3><a href="#autotoc_md93">Rectangles</a></h3><p>Open <code>quad.h</code> and <code>quad.cpp</code>, and implement the <code>sample</code> and <code>pdf</code> functions for the <code>Quad</code> class.</p><p>For <code>sample</code>, you should generate a random point on the rectangle (using your function from earlier) and return the normalized direction from <code>o</code> to the point you generated.</p><aside class="m-block m-success"><h3>Hint</h3><p>You can get the vectors for the two sides of the rectangle using</p><pre>v0 = m_xform.vector({m_size.x, 0, 0})  
v1 = m_xform.vector({0, m_size.y, 0})
</pre></aside><p>For <code>pdf</code>, you should check if the given direction hits the quad from the given origin. If not, return 0; otherwise, return 1/area times the geometry factor.</p><aside class="m-block m-success"><h3>Hint</h3><p>The length of the cross product of <code>v0</code> and <code>v1</code> is exactly 1/4th of the surface area.</p></aside><p>After you&#x27;ve implemented these functions, test your code using the sample tester tool. You should get images like these for <code>quad-pdf.png</code> and <code>quad-sampled.png</code>:</p><div class="twentytwenty-container"><img class="m-image" src="quad-pdf.png" alt="Image" />
 <img class="m-image" src="quad-sampled.png" alt="Image" /></div></section><section id="autotoc_md94"><h3><a href="#autotoc_md94">Triangles</a></h3><p>Go to <code>mesh.h</code> and <code>mesh.cpp</code>, and implement <code>sample</code> and <code>pdf</code> for the <code>Triangle</code> class. Use exactly the same recipe as you did for the quad - all that needs to change is how to get a point on the surface, and the computation of the surface area. Look at <code>Triangle::intersect</code> for inspiration for how to get the three corners of the triangle (p0, p1 and p2). Hint: The length of the cross product of any two sides of the triangle is twice the triangle area.</p><div class="twentytwenty-container"><img class="m-image" src="triangle-pdf.png" alt="Image" />
 <img class="m-image" src="triangle-sampled.png" alt="Image" /></div></section><section id="autotoc_md95"><h3><a href="#autotoc_md95">Spheres</a></h3><p>Open <code>sphere.h</code> and <code>sphere.cpp</code>, and implement <code>sample</code> and <code>pdf</code> for the <code>Sphere</code> class.</p><p>We will use a different approach for sampling the sphere: Instead of sampling a point on the sphere first and computing the direction towards it, we will directly sample the spherical cap of directions that all point towards the sphere. To do this, you can use your function for sampling spherical caps from the first task. However, to use this function you need to first figure out cos_theta_max, the angular extent of the sphere at <code>o</code>. You can compute it with <code>cos_theta_max = sqrt(d*d - r*r)/d</code> where <code>d</code> is the distance from the center of sphere to <code>o</code>, and <code>r</code> is the radius of the sphere. Hint: Can this formula fail? When does this happen? What should the value of <code>cos_theta_max</code> be in that case?</p><p>The sampling function you implemented in task 1 assumes the spherical cap is aligned with the z axis. You should use the ONB to transform the sampled direction, so that the spherical cap points from <code>o</code> towards the center of the sphere instead.</p><p>For <code>pdf</code>, you should first check if the given origin/direction intersect with the sphere. If they do, the pdf is simply 1/solid angle of the spherical cap (no geometry factor needed - we generated directions directly!). The solid angle of a spherical cap with opening angle of thetaMax is <code>2*pi*(1-cos_theta_max)</code>.</p><p>Test your code with the sample tester tool. You should get images like these:</p><div class="twentytwenty-container"><img class="m-image" src="sphere-pdf.png" alt="Image" />
 <img class="m-image" src="sphere-sampled.png" alt="Image" /></div></section><section id="autotoc_md96"><h3><a href="#autotoc_md96">Surface Groups</a></h3><p>Open <code>surface_group.h</code> and <code>surface_group.cpp</code> and implement the sampling interface for the <code>SurfaceGroup</code> class. This class represents a collection of shapes (e.g. the list of all lights in the scene), which are stored in the array <code>m_surfaces</code>. For <code>sample</code>, you should randomly generate an integer index in range <code>0...m_surfaces.size() - 1</code> (inclusive) and call the <code>sample</code> method of the shape at that index in the array. For <code>pdf</code>, you should call the <code>pdf</code> method of each shape in the list, and return the average of all the pdf evaluations. Hint: You can use the following syntax to iterate over all shapes:</p><pre class="m-code"><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="nl">surface</span> <span class="p">:</span><span class="w"> </span><span class="n">m_surfaces</span><span class="p">)</span><span class="w">  </span>
<span class="w">    </span><span class="n">surface</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">(...);</span><span class="w"></span></pre></section></section><section id="autotoc_md97"><h2><a href="#autotoc_md97">Task 3: Integrating Lights</a></h2><p><span class="m-label m-primary m-flat">7 pts</span></p><p>In this task, you will implement better integrators for direct lighting. You will use the sampling interfaces you implemented in the earlier task to explicitly guide rays towards light sources.</p><p>Note that the algorithm described in this assignment is slightly different from the pseudo-code shown in class: Both algorithms will work, and you are free to implement either version, as long as it gives you the correct image.</p><section id="autotoc_md98"><h3><a href="#autotoc_md98">Direct Lighting Material Integrator</a></h3><div class="m-col-s-6 m-col-m-5 m-right-s"><a href="veach_mats-ref.png"><img class="m-image" src="veach_mats-ref.png" alt="Image" /></a></div><p>Begin by implementing a baseline <code>DirectMats</code> integrator that integrates direct lighting by simply sampling the material. This is a simpler version of your integrator from last time - remove the recursive part, and only shoot a single ray after the first hit to return <code>eval/pdf*emission</code>. Make sure to register this integrator with the <code>DirtsFactory</code> by adding the macro at the bottom of your implementation file. Associate it with the string <code>&quot;direct_mats&quot;</code>.</p><p>Test your integrator by running it on <code>scenes/assignment5/veach_mats.json</code>. You should get an image like the one shown here.</p><p>Most of this image looks extremely noisy, especially the background and the reflections in the lower right. We can do better than this!</p></section><section id="autotoc_md99"><h3><a href="#autotoc_md99">Creating a list of scene emitters</a></h3><p>Instead of asking the <code>Material</code> to generate ray directions for us, we could instead generate ray directions by sampling points on all surfaces in the scene using our new <code>Surface::sample()</code> function. As it is now, however, this would not be so useful, since most surfaces in the scene do not emit light. We&#x27;d like to sample rays towards surfaces that emit light. To do that we first need to add some plumbing to our code to allow a <code>Scene</code> to maintain a list of only the emissive surfaces.</p></section><section id="autotoc_md100"><h3><a href="#autotoc_md100">Next Event Integrator</a></h3><p>Add a new integrator class called <code>DirectNEE</code>, and register it with the factory using the string <code>&quot;direct_nee&quot;</code>. The &quot;NEE&quot; part stands for <em>Next Event Estimation</em>, which is a fancy name for sampling light sources directly.</p><div class="m-col-s-6 m-col-m-5 m-right-s"><a href="veach_nee-ref.png"><img class="m-image" src="veach_nee-ref.png" alt="Image" /></a></div><p>On a basic level, this integrator looks very similar to the material-based integrator from the previous subtask (and you can start by copy-pasting that code). However, instead of calling <code>Material::sample</code> to produce a direction, it should call <code>scene.emitters().sample()</code>. <code>scene.emitters()</code> is a <code>SurfaceGroup</code> that contains all emissive shapes in the scene. Similarly, instead of dividing by <code>Material::pdf</code>, you should divide by <code>scene.emitters().pdf()</code>.</p><p>This (for the first time) shows the flexibility of the Monte Carlo approach: All you had to change was the sampling and PDF routine, and you get a noise-free image much faster! This would not have been possible with the renderer you wrote in Assignment 1. Convince yourself that this integrator has much less noise by running your new code on <code>scenes/assignment5/veach_nee.json</code>. You should get an image looking like the one shown here.</p><p>This looks <em>much</em> better than the <code>DirectMats</code> integrator for most of the image... except for the upper left, where the NEE estimator does much worse. Just like discussed in class, we can fix this by using both estimators, and combining them with MIS.</p></section><section id="autotoc_md101"><h3><a href="#autotoc_md101">MIS Integrator</a></h3><p>Add a new integrator class called <code>DirectMIS</code>, and add it to the <code>parseIntegrator</code> function for type <code>&quot;direct_mis&quot;</code>. The MIS part stands for&nbsp;<em>Multiple Importance Sampling</em>, which is a technique for efficiently combining multiple integration techniques.</p><p>Begin by copy-pasting either your <code>DirectMIS</code> or your <code>DirectNEE</code> integrator from before. Instead of always sampling from the material, or always from the light source, you should sample from a <em>mixture</em> of both of them. With probability of 0.5, generate a direction by sampling the material; otherwise, generate a direction by sampling the lights. After you&#x27;ve generated a direction, trace a ray and evaluate the emission and material like before; however, instead of dividing by just the material pdf or the light PDF, divide by the&nbsp;<em>average</em> of the two PDFs (since you randomly sample from either one).</p><p>Test your integrator on <code>scenes/assignment5/veach_mis.json</code>. You should get an image like below:</p><div class="twentytwenty-container"><img class="m-image" src="veach_mats-ref.png" alt="Image" />
 <img class="m-image" src="veach_nee-ref.png" alt="Image" />
 <img class="m-image" src="veach_mis-ref.png" alt="Image" /></div><p>The integrator now works robustly in all parts of the scene, and combines the good traits of both material sampling and light sampling.</p><p>Also test your integrators on <code>scenes/assignment5/odyssey_XXX.json</code>. Here is our comparison:</p><div class="twentytwenty-container"><img class="m-image" src="odyssey_mats-ref.png" alt="Image" />
 <img class="m-image" src="odyssey_nee-ref.png" alt="Image" />
 <img class="m-image" src="odyssey_mis-ref.png" alt="Image" /></div></section><section id="autotoc_md102"><h3><a href="#autotoc_md102">Full Path Tracing</a></h3><p>Extend the <code>DirectMIS</code> integrator from the previous subtask to do not just direct lighting, but all direct and indirect lighting. You can start by copy-pasting your code for <code>DirectMIS</code>: This code will currently find the closest hit point along the given ray, estimate direct lighting at that location and exit. All you need to do in order to support indirect light is to add recursion before exiting: After computing direct lighting, sample the material to obtain the next ray along the path, and call the function recursively with the new ray to obtain an estimate of indirect lighting. Divide that estimate by the material sampling PDF, and add this estimate to the direct lighting estimate. That&#x27;s it! In our code, we&#x27;ve created a new integrator class called <code>&quot;PathTracerMIS&quot;</code> to do this. You could instead also add the recursive functionality to your current direct lighting integrator, and add a JSON parameter for limiting the recursion depth. No recursion gives you direct lighting only, and anything beyond that gives you global illumination with increasing numbers of interreflections. Either way works - pick the one that you prefer.</p><p><strong>Grad Students: Optimize your DirectMIS integrator</strong>. In the current version, you sample the material and trace a ray once for direct lighting, and a second time for the recursive ray. This is wasteful - they can both use the same ray and intersection (intersecting the scene is expensive!). Optimize your implementation to reuse the material ray and intersection for the recursive call. You can check the lecture slides for ideas on how to do this.</p><aside class="m-block m-success"><h3>Hint</h3><p>With the randomized MIS approach, you only sample the material 50% of the time, so you don&#x27;t always have that ray available. You can simplify it by removing randomness and always taking one light sample and one material sample, and averaging the direct light estimates from both. Then, reuse the ray and intersection sampled from the material for the recursive call.</p></aside><p>Test your new integrators on <code>scenes/assignment5/glossy-cornell-box_mis.json</code>.</p><div class="m-row m-container-inflate"><div class="m-col-s-4"><a href="sphere_light_small-ref.png"><img class="m-image" src="sphere_light_small-ref.png" alt="Image" /></a></div><div class="m-col-s-4"><a href="sphere_light_medium-ref.png"><img class="m-image" src="sphere_light_medium-ref.png" alt="Image" /></a></div><div class="m-col-s-4"><a href="sphere_light_large-ref.png"><img class="m-image" src="sphere_light_large-ref.png" alt="Image" /></a></div></div></section></section><section id="autotoc_md103"><h2><a href="#autotoc_md103">What to submit</a></h2><p>In your report, make sure to include:</p><ul><li>Visualized point sets for all distributions from task 1</li><li>Rendered images of all the scenes in <code>scenes/assignment5</code></li></ul><p>Then submit according to the instructions in the <a href="getting-started.html#submitting-on-canvas" class="m-doc">Submitting on Canvas</a> section of <a href="getting-started.html" class="m-doc">Getting started</a> guide.</p></section>
        <div class="m-note m-dim m-thin m-text-center"><a href="assignment4.html" class="m-doc">&laquo; A4: Sampling materials</a> | <a href="assignments.html" class="m-doc">Assignments</a> | <a href="assignment6.html" class="m-doc">A6: Final project &raquo;</a></div>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v1.js"></script>
<script src="searchdata-v1.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>CS
87/287 Rendering Algorithms. Created with <a href="https://doxygen.org/">Doxygen</a> 1.8.17 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
