<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Assignments &raquo; A3: Textures | CS
87/287 Rendering Algorithms</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark.css" />
  <link rel="stylesheet" href="m-documentation.css" />
  <link rel="icon" href="favicon.png" type="image/png" />
  <link rel="prev" href="assignment2.html" />
  <link rel="next" href="assignment4.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script><script src="jquery.event.move.js"></script><script src="jquery.twentytwenty.js"></script><link href="twentytwenty.css" rel="stylesheet" type="text/css" /><script>$(window).load(function(){$(".twentytwenty-container").twentytwenty({default_offset_pct: 0.5, move_slider_on_hover: true });});</script>
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://cs87-dartmouth.github.io/Fall2021"><img src="darts-logo.svg" alt="" />CS
87/287</a> <span class="m-breadcrumb">|</span> <a href="index.html" class="m-thin">Rendering Algorithms</a>
      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="schedule.html">Schedule</a></li>
            <li>
              <a href="assignments.html">Assignments</a>
              <ol>
                <li><a href="assignment0.html">A0: Darts preliminaries</a></li>
                <li><a href="assignment1.html">A1: Ray tracing</a></li>
                <li><a href="assignment2.html">A2: Ray tracing faster</a></li>
                <li><a href="assignment3.html" id="m-navbar-current">A3: Textures</a></li>
                <li><a href="assignment4.html">A4: Sampling materials</a></li>
                <li><a href="assignment5.html">A5: Sampling lights</a></li>
                <li><a href="assignment6.html">A6: Final project</a></li>
              </ol>
            </li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li>
              <a href="darts-overview.html">Code</a>
              <ol>
                <li><a href="darts-overview.html">Darts</a></li>
                <li><a href="getting-started.html">Getting started</a></li>
                <li><a href="https://github.com/cs87-dartmouth/Fall2021">GitHub</a></li>
                <li><a href="modules.html">Modules</a></li>
                <li><a href="annotated.html">Classes</a></li>
                <li><a href="files.html">Files</a></li>
              </ol>
            </li>
            <li><a href="credits.html">Credits</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="assignments.html">Assignments</a> &raquo;</span>
          A3: Textures
        </h1>
        <nav class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              <a href="#autotoc_md59">Task 1: The Texture class</a>
              <ul>
                <li><a href="#autotoc_md60">Constant textures</a></li>
                <li><a href="#autotoc_md61">Retrofitting the parser</a></li>
                <li><a href="#autotoc_md62">Backwards scene compatibility</a></li>
              </ul>
            </li>
            <li>
              <a href="#autotoc_md63">Task 2: Solid textures</a>
              <ul>
                <li><a href="#autotoc_md64">Checkerboard</a></li>
                <li><a href="#autotoc_md65">Perlin noise</a></li>
                <li><a href="#autotoc_md66">Transforming texture lookups (optional)</a></li>
              </ul>
            </li>
            <li>
              <a href="#autotoc_md67">Task 3: Image texture mapping</a>
              <ul>
                <li><a href="#autotoc_md68">The ImageTexture class</a></li>
                <li><a href="#autotoc_md69">Texture coordinates</a></li>
              </ul>
            </li>
            <li><a href="#autotoc_md70">Task 4: Fresnel blend material</a></li>
            <li><a href="#autotoc_md71">Task 5: Interesting scene</a></li>
            <li><a href="#autotoc_md72">What to submit</a></li>
          </ul>
        </nav>
<aside class="m-note m-danger"><h3>Note</h3><p>Make sure to do a <code>git pull upstream main</code> to retrieve any updates to the base code before you begin!</p></aside><p>We will primarily be referring to chapters of <a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html">Ray Tracing - The Next Week</a> in this assignment.</p><section id="autotoc_md59"><h2><a href="#autotoc_md59">Task 1: The Texture class</a></h2><p>Read <a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html#solidtextures">Ray Tracing - The Next Week: Chapter 4</a>, and create a <code>Texture</code> base class following this chapter (perhaps in a new <code>texture.h</code> file within your <code>include/darts</code> directory. Remember to add this file to the list of headers or source files in <code>CMakeLists.txt</code>. Instead of accepting <code>u</code>, <code>v</code>, and <code>p</code> parameters as done in the book, we suggest you have your <code>Texture::value()</code>&nbsp;function take a <code>const HitInfo &amp;</code> as the parameter (you can then retrieve <code>u</code>, <code>v</code>, and <code>p</code> from within this <code>HitInfo</code>).</p><p>Here is what our interface looks like:</p><pre class="m-code"><span class="c1">// Base class for all textures</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Texture</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">Texture</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">json</span><span class="w"> </span><span class="o">&amp;</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">json</span><span class="o">::</span><span class="n">object</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Texture</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">Color3f</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">HitInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hit</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span></pre><p>We put our implementation file in <code>src/textures/texture.cpp</code>.</p><section id="autotoc_md60"><h3><a href="#autotoc_md60">Constant textures</a></h3><p>Create a derived <code>class ConstantTexture : public Texture</code>&nbsp;which has&nbsp;a member variable <code>Color3f color;</code>&nbsp;and whose&nbsp;<code>value(...)</code> function&nbsp;just returns it. Make a constructor that takes a <code>const json &amp;j</code> and tries to assign the parameter named <code>&quot;color&quot;</code> to your color member variable by using <code>j.value(&quot;color&quot;, color);</code>. We put both our class definition and implementation into the file <code>src/textures/constant.cpp</code>.</p></section><section id="autotoc_md61"><h3><a href="#autotoc_md61">Retrofitting the parser</a></h3><p>To make this work with the rest of darts, we need to refactor our code a bit so that <code>Material</code>s use <code>Texture</code>s instead of <code>Color3f</code>s, and so that it plays nice with our JSON parser.</p><p>We first need to inform our JSON parser how to create each type of texture, and what type string (e.g. <code>&quot;constant&quot;</code>) to look for when creating it. Calling the following macro at the bottom of <code>src/textures/constant.cpp</code> will do this for the new <code>ConstantTexture</code>:</p><pre class="m-code"><span class="n">DARTS_REGISTER_CLASS_IN_FACTORY</span><span class="p">(</span><span class="n">Texture</span><span class="p">,</span><span class="w"> </span><span class="n">ConstantTexture</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;constant&quot;</span><span class="p">)</span><span class="w"></span></pre><p>Now, change all the <code>Color3f</code> members of your <code>Material</code>s to <code>Texture</code>s, e.g. <code>Color3f albedo;</code> in <code>Lambertian</code> becomes <code>shared_ptr&lt;const Texture&gt; albedo;</code>. You&#x27;ll also need to change the corresponding constructors of any <code>Material</code> to call <code>DartsFactory::create()</code> instead of reading a color directly from the passed <code>json</code> object, e.g. this:</p><pre class="m-code"><span class="n">albedo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="s">&quot;albedo&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">albedo</span><span class="p">);</span><span class="w"></span></pre><p>becomes:</p><pre class="m-code"><span class="n">albedo</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">DartsFactory</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;::</span><span class="n">create</span><span class="p">(</span><span class="n">j</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;albedo&quot;</span><span class="p">));</span><span class="w"></span></pre><p><code>DartsFactory::create()</code> will look for a <code>&quot;type&quot;</code> field in the passed-in <code>json</code> object, and create the appropriate <code>Texture</code> subclass. This works because of the <code>DARTS_REGISTER_CLASS_IN_FACTORY</code> macro we called earlier.</p><p>You&#x27;ll also want to support texturing the <code>Metal::roughness</code> parameter. This is currently a float, but you can still turn it into a <code>Texture</code>, and when calling its <code>value(...)</code> function, just convert to a scalar using the <code><a href="group__group__math.html#gade8d7f28c384dd15c84b8081f846e79c" class="m-doc">luminance()</a></code>&nbsp;function in <code><a href="vec_8h.html" class="m-doc">darts/<wbr />vec.h</a></code>. An alternative approach would have been to treat color and grayscale textures separately, or allow roughness to differ across the three color channels, but we&#x27;ll stick with the simpler approach.</p><div class="m-col-s-6 m-col-m-4 m-right-s"><a href="constant-cornell-box-ref.png"><img class="m-image" src="constant-cornell-box-ref.png" alt="Image" /></a></div><p>Once you have this implemented, you should be able to render the scene <code>scenes/assignment3/constant-cornell-box.json</code>.&nbsp;This scene looks similar to the Cornell box from the previous assignment, except all albedos are now specified with a constant texture.</p><div class="m-clearfix-s"></div><div class="m-clearfix-m"></div><div class="m-clearfix-l"></div></section><section id="autotoc_md62"><h3><a href="#autotoc_md62">Backwards scene compatibility</a></h3><p>One nuisance with our current solution is that we would have to re-write all our previous scene files&nbsp;(that directly specified a color)&nbsp;to instead use a <code>&quot;constant&quot;</code> texture. Previously we could have simply written:<br /></p><pre class="m-code"><span class="nt">&quot;albedo&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mf">0.8</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">],</span><span class="w"></span></pre><p>in the scene file, but now we have to write the more clunky:<br /></p><pre class="m-code"><span class="nt">&quot;albedo&quot;</span><span class="p">:</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;constant&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;color&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mf">0.8</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>Let&#x27;s add backwards compatibility so that the scene can specify colors directly too.</p><p>Take a look at <code>DartsFactory::create()</code> in <code>darts/factory.h</code>. Recall that this method of our <code>DartsFactory</code> is responsible for creating instances of materials, surfaces, etc. (determined by the base class <code>T</code>) by checking for a <code>&quot;type&quot;</code> field in the passed-in <code>json</code> object. We&#x27;d like the factory to do something a bit more sophisticated when we try to create a subclass of <code>Texture</code>.</p><p>To do that, we&#x27;ll need to create a specialization of the <code>DartsFactory::create()</code> method that is used specifically when the template type is a <code>Texture</code>. Create a method in <code>factory.h</code> with the following signature (just below the current <code>DartsFactory::create()</code> implementation):</p><pre class="m-code"><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"></span>
<span class="kr">inline</span><span class="w"> </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;</span><span class="w"> </span><span class="n">DartsFactory</span><span class="o">&lt;</span><span class="n">Texture</span><span class="o">&gt;::</span><span class="n">create</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">json</span><span class="w"> </span><span class="o">&amp;</span><span class="n">j</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// your code here</span>
<span class="p">}</span><span class="w"></span></pre><p>Start by copying over the implementation of the generic <code>DartsFactory::create()</code> method.</p><p>To allow backwards compatibility, you can inspect the <code>const json &amp;j</code> by calling <code>j.is_object()</code>, <code>j.is_array()</code> or <code>j.is_number()</code>.&nbsp;If <code>j</code> is an object, you can proceed just as in the generic implementation to construct the appropriate <code>Texture</code>. However, if <code>j</code> is an array or number, you should create a <code>ConstantTexture</code> directly (you may also need to modify the <code>ConstantTexture</code> constructor to handle this).</p><p>Once you have this implemented, you should be able to render all the scenes from the previous assignment. Give it a try.</p></section></section><section id="autotoc_md63"><h2><a href="#autotoc_md63">Task 2: Solid textures</a></h2><p>You now have the framework to easily add other types of textures, and these textures can be used any place you previously used a fixed <code>Color3f</code>!</p><section id="autotoc_md64"><h3><a href="#autotoc_md64">Checkerboard</a></h3><div class="m-col-s-6 m-col-m-4 m-right-s"><a href="checker-ref.png"><img class="m-image" src="checker-ref.png" alt="Image" /></a></div><p>Add a <code>CheckerTexture</code> class following the description in <a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html#solidtextures/acheckertexture">Section 4.3</a> of the book, but adapted to the darts framework. Your constructor should look for fields named <code>&quot;odd&quot;</code> and <code>&quot;even&quot;</code> and use those together with <code>DartsFactory&lt;Texture&gt;::create()</code> to create the corresponding odd and even textures. Make sure to register the new texture with the factory using the <code>DARTS_REGISTER_CLASS_IN_FACTORY</code> macro like before, but this time associate it with the type string <code>&quot;checker&quot;</code>.</p><p>Once you have this implemented, you should be able to render the scene <code>scenes/assignment3/checker.json</code> producing an image like the one shown here.</p><div class="m-clearfix-s"></div><div class="m-clearfix-m"></div><div class="m-clearfix-l"></div></section><section id="autotoc_md65"><h3><a href="#autotoc_md65">Perlin noise</a></h3><div class="m-col-s-6 m-col-m-4 m-right-s"><a href="marble-128spp.png"><img class="m-image" src="marble-128spp.png" alt="Image" /></a></div><p>Read <a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html#perlinnoise">Chapter 5</a> of the book. Implement the <code>Perlin</code> class. Also implement the <code>noise_texture</code> class from the book, but call this <code>MarbleTexture</code> instead. Allow the JSON scene file to specify the <code>scale</code> member variable of your <code>MarbleTexture</code>, and instead of always interpolating between black and white as in the book, allow the user to specify these two colors in the JSON scene file just like we did with <code>&quot;odd&quot;</code> and <code>&quot;even&quot;</code> for the checkerboard. Look for the named fields <code>&quot;veins&quot;</code> and <code>&quot;base&quot;</code> in the JSON object for this purpose. Make sure to register the texture with the <code>DartsFactory</code> and add your <code>Perlin</code> and <code>MarbleTexture</code> file to your <code>CMakeLists.txt</code>.</p><p>Render <code>scenes/assignment3/marble.json</code>.</p><div class="m-clearfix-s"></div><div class="m-clearfix-m"></div><div class="m-clearfix-l"></div></section><section id="autotoc_md66"><h3><a href="#autotoc_md66">Transforming texture lookups (optional)</a></h3><p>Particularly with procedural textures, you might find it useful to be able to scale, rotate, and otherwise transform how the textures are placed on your surfaces. You could accomplish this by adding a <code>Transform xform;</code> member variable in any <code>Texture</code> that needs this, and transform the lookup point (<code>hit.p</code>) by <code>xform</code> in the class&#x27;s <code>value(const HitInfo &amp; hit)</code> method. To avoid duplicating this functionality in each derived class that needs it, we simply added the <code>Transform xform;</code> member variable directly to the <code>Texture</code> base class, so all textures inherit it. We read this in from the <code>json</code> object in the <code>Texture</code> base class constructor <code>Texture::Texture(const json &amp; j)</code>, but only look for it if <code>j.is_object() == true</code>. This allows our shorthand for specifying constant colors directly as <code>json</code> arrays to continue working.</p></section></section><section id="autotoc_md67"><h2><a href="#autotoc_md67">Task 3: Image texture mapping</a></h2><section id="autotoc_md68"><h3><a href="#autotoc_md68">The ImageTexture class</a></h3><p>Read <a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html#imagetexturemapping">Chapter 6</a> of the book and implement image texturing mapping. We already provide you with image loading support, which you should&nbsp;leverage using the <code><a href="classImage3f.html" class="m-doc">Image3f</a></code> class defined in <code><a href="image_8h.html" class="m-doc">include/<wbr />darts/<wbr />image.h</a></code> and <code><a href="image_8cpp.html" class="m-doc">src/<wbr />image.cpp</a></code>. Your <code>ImageTexture</code> class should accept a <code>&quot;filename&quot;</code>&nbsp;string parameter from the <code>json</code> object. Once you read this string, use the global file resolver to resolve this filename into a path, like so:</p><pre class="m-code"><span class="n">string</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_file_resolver</span><span class="p">().</span><span class="n">resolve</span><span class="p">(</span><span class="n">filename</span><span class="p">).</span><span class="n">str</span><span class="p">();</span><span class="w"></span></pre><p><code><a href="common_8h.html#a0395cc6b6ad5e785b9ffdbdeddac3d17" class="m-doc">get_<wbr />file_<wbr />resolver()</a></code>&nbsp;is defined in <code><a href="common_8h.html" class="m-doc">darts/<wbr />common.h</a></code>.</p></section><section id="autotoc_md69"><h3><a href="#autotoc_md69">Texture coordinates</a></h3><p>Extend your <code>Sphere::intersect()</code> function to output the UV coordinates as <a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html#solidtextures/texturecoordinatesforspheres">described in the book</a>. Since there are many different conventions for spherical coordinates and uv coordinates, we already provide handy functions to consistently perform the Cartesian-to-spherical or spherical-to-Cartesian coordinate mappings for you. They are <code><a href="common_8h.html#a4bded62d9e4570f2feb3e1f365e6288a" class="m-doc">direction_<wbr />to_<wbr />spherical_<wbr />uv()</a></code> and <code><a href="common_8h.html#acc3732f226e2125f7646cd849b7e37e5" class="m-doc">spherical_<wbr />uv_<wbr />to_<wbr />direction()</a></code> in <code><a href="common_8h.html" class="m-doc">include/<wbr />darts/<wbr />common.h</a></code>. You should now be able to render <code>scenes/assignment3/earth.json</code>.</p><p>Next, extend your <code>Quad::intersect()</code> function to output UV coordinates. Render <code>scenes/assignment3/textured-box.json</code>.&nbsp;</p><p>Finally, extend <code>single_triangle_intersect()</code> to output UV coordinates. The function already receives three parameters (<code>t0</code>, <code>t1</code>, and <code>t2</code>) that specify the UV texture coordinates at the three triangle vertices. As with the normals, if the mesh doesn&#x27;t provide per-vertex UV coordinates <code>Triangle::intersect()</code> passes <code>nullptr</code>s for the <code>t0</code>, <code>t1</code>, and <code>t2</code> parameters and you&#x27;ll need to fall back to some reasonable default. In this case, you should just store the barycentric coordinates in place of interpolated UV coordinates in <code>hit.uv</code>.</p><p>If you render <code>scenes/02/triangles_textures/teapot.json</code> you should see a scene with a teapot mesh that has texture coordinates and a texture applied, as shown below.</p><div class="m-row m-container-inflate"><div class="m-col-t-6 m-col-s-4"><a href="earth-ref.png"><img class="m-image" src="earth-ref.png" alt="Image" /></a></div><div class="m-col-t-6 m-col-s-4"><a href="textured-box-ref.png"><img class="m-image" src="textured-box-ref.png" alt="Image" /></a></div><div class="m-col-t-6 m-col-s-4"><a href="teapot-ref.png"><img class="m-image" src="teapot-ref.png" alt="Image" /></a></div></div></section></section><section id="autotoc_md70"><h2><a href="#autotoc_md70">Task 4: Fresnel blend material</a></h2><p>Many real-world materials have a more complex structure because the surface actually consist of multiple layers: e.g. a clear varnish on top of wood. There are many sophisticated techniques in graphics that try to model such multiple layers in a physically based way. We will instead take a physically inspired but simple approach to blend between a dielectric varnish and a substrate layer based on the index of refraction of the varnish.</p><p>Implement the class <code>FresnelBlendMaterial</code> in a new file <code>src/materials/fresnel_blend.cpp</code>. This material will compute the percentage of light that should reflect vs. refract off the surface using the Fresnel equations, and then call a different <code>scatter()</code> function for each. To handle this, the material should store two <code>shared_ptrs</code> to <code>Materials</code> (specified as <code>&quot;refl&quot;</code> and <code>&quot;refr&quot;</code> in the JSON file) and a <code>shared_ptr</code> to a <code>Texture</code> (<code>&quot;ior&quot;</code> in JSON) specifying the index of refraction of the varnish layer (which will indirectly influence the blend amount between the reflection vs. refraction materials). Make sure to register the new material with the <code>DartsFactory</code> and add it to your <code>CMakeLists.txt</code> file.</p><p>In the <code>FresnelBlendMaterial::scatter()</code> function, evaluate the Fresnel equations using the index of refraction in the <code>ior</code> texture (e.g. converted to a scalar using <code><a href="group__group__math.html#gade8d7f28c384dd15c84b8081f846e79c" class="m-doc">luminance()</a></code>). The book favors the fast approximation to the Fresnel equations proposed by Schlick. You are free to implement/use this if you like. We also provide an implementation of the full Fresnel equations as <code>fresnel()</code> in <code><a href="common_8h.html" class="m-doc">include/<wbr />darts/<wbr />common.h</a></code>. Using the calculated reflection percentage, draw a random number using <code>randf()</code>. If <code>randf()</code> is less than the reflection amount, then call the <code>scatter()</code> function of material <code>refl</code>, otherwise, call the <code>scatter()</code> function of material <code>refr</code>.</p><p>Render <code>scenes/assignment3/fresnel_blend.json</code>.</p><div class="m-row m-container-inflate"><div class="m-col-t-12"><a href="fresnel_blend-ref.png"><img class="m-image" src="fresnel_blend-ref.png" alt="Image" /></a></div></div></section><section id="autotoc_md71"><h2><a href="#autotoc_md71">Task 5: Interesting scene</a></h2><p>Now create an interesting scene (or scenes) showcasing all the features you&#x27;ve implemented. Be creative. Find some interesting meshes and textures online, or create some new procedural textures by combining your existing functionality. Consider applying textures to various parts of a material, like the blend factor, the roughness, and emission. <a href="https://sketchfab.com/feed">Sketchfab.com</a> and <a href="https://polyhaven.com/models">polyhaven.com</a> have thousands of high-quality textured meshes available for free. Here&#x27;s a few that we created and provide the scene files for:</p><div class="m-row m-container-inflate"><div class="m-col-t-4 m-col-s-4"><a href="ajax-textured-ref.png"><img class="m-image" src="ajax-textured-ref.png" alt="Image" /></a></div><div class="m-col-t-4 m-col-s-4"><a href="nefertiti-textured-ref.png"><img class="m-image" src="nefertiti-textured-ref.png" alt="Image" /></a></div><div class="m-col-t-4 m-col-s-4"><a href="loewenfeld-textured-ref.png"><img class="m-image" src="loewenfeld-textured-ref.png" alt="Image" /></a></div></div></section><section id="autotoc_md72"><h2><a href="#autotoc_md72">What to submit</a></h2><p>In your report, make sure to include:</p><ul><li>Rendered images of all the scenes in <code>scenes/assignment3</code> and your interesting scene</li></ul><p>Then submit according to the instructions in the <a href="getting-started.html#submitting-on-canvas" class="m-doc">Submitting on Canvas</a> section of <a href="getting-started.html" class="m-doc">Getting started</a> guide.</p></section>
        <div class="m-note m-dim m-thin m-text-center"><a href="assignment2.html" class="m-doc">&laquo; A2: Ray tracing faster</a> | <a href="assignments.html" class="m-doc">Assignments</a> | <a href="assignment4.html" class="m-doc">A4: Sampling materials &raquo;</a></div>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>CS 87/287 Rendering Algorithms. Created with <a href="https://doxygen.org/">Doxygen</a> 1.8.17 and <a href="https://mcss.mosra.cz/">m.css</a>.<br />See <a href="credits.html">credits page</a> for additional acknowledgements.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
