<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Assignments &raquo; A4: Sampling materials | CS
87/287 Rendering Algorithms</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark.css" />
  <link rel="stylesheet" href="m-documentation.css" />
  <link rel="icon" href="favicon-dark.png" type="image/png" />
  <link rel="prev" href="assignment3.html" />
  <link rel="next" href="assignment5.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script><script src="jquery.event.move.js"></script><script src="jquery.twentytwenty.js"></script><link href="twentytwenty.css" rel="stylesheet" type="text/css" /><script>$(window).load(function(){$(".twentytwenty-container").twentytwenty({default_offset_pct: 0.5, move_slider_on_hover: true });});</script>
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://cs87-dartmouth.github.io/Fall2021"><img src="darts-logo.svg" alt="" />CS
87/287</a> <span class="m-breadcrumb">|</span> <a href="index.html" class="m-thin">Rendering Algorithms</a>
      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li>
              <a href="assignments.html">Assignments</a>
              <ol>
                <li><a href="assignment0.html">A0: Darts preliminaries</a></li>
                <li><a href="assignment1.html">A1: Ray tracing</a></li>
                <li><a href="assignment2.html">A2: Ray tracing faster</a></li>
                <li><a href="assignment3.html">A3: Textures</a></li>
                <li><a href="assignment4.html" id="m-navbar-current">A4: Sampling materials</a></li>
                <li><a href="assignment5.html">A5: Sampling lights</a></li>
                <li><a href="assignment6.html">A6: Final project</a></li>
              </ol>
            </li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="2">
            <li>
              <a href="darts-overview.html">Code</a>
              <ol>
                <li><a href="darts-overview.html">Code</a></li>
                <li><a href="getting-started.html">Getting started</a></li>
                <li><a href="modules.html">Modules</a></li>
                <li><a href="annotated.html">Classes</a></li>
                <li><a href="files.html">Files</a></li>
              </ol>
            </li>
            <li><a href="credits.html">Credits</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="assignments.html">Assignments</a> &raquo;</span>
          A4: Sampling materials
        </h1>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              <a href="#sampling-distributions">Task 1: Sampling distributions</a>
              <ul>
                <li><a href="#autotoc_md73">Avoiding rejection sampling</a></li>
                <li><a href="#autotoc_md74">Uniform points on the sphere</a></li>
                <li><a href="#autotoc_md75">Uniform points on the hemisphere</a></li>
                <li><a href="#autotoc_md76">Cosine-weighted points on the hemisphere</a></li>
                <li><a href="#autotoc_md77">Cosine-power-weighted points on the hemisphere</a></li>
              </ul>
            </li>
            <li>
              <a href="#autotoc_md78">Task 2: Sampling materials</a>
              <ul>
                <li><a href="#autotoc_md79">Lambertian sampling</a></li>
                <li><a href="#autotoc_md80">Testing your code</a></li>
                <li><a href="#autotoc_md81">Oriented samples</a></li>
                <li><a href="#autotoc_md82">Phong material</a></li>
                <li><a href="#autotoc_md83">Grad students only: Blinn-Phong</a></li>
              </ul>
            </li>
            <li><a href="#autotoc_md84">Task 3: Samplers</a></li>
            <li>
              <a href="#autotoc_md85">Task 4: Integrators</a>
              <ul>
                <li><a href="#autotoc_md86">Normal integrator</a></li>
                <li><a href="#autotoc_md87">Ambient occlusion integrator</a></li>
                <li><a href="#autotoc_md88">Material sampling integrator</a></li>
              </ul>
            </li>
            <li><a href="#autotoc_md89">What to submit</a></li>
          </ul>
        </div>
<aside class="m-note m-danger"><h3>Note</h3><p>Make sure to do a <code>git pull upstream remote</code> to retrieve any updates to the base code before you begin!</p></aside><p>In this assignment, we will take a deep dive into implementing a Monte Carlo renderer. Monte Carlo is a powerful technique for approximating integrals, and it is the dominant technique for rendering images in the movie industry and, increasingly, video games.</p><p>It turns out that the renderer you have been writing so far already did Monte Carlo integration in secret - but it was cleverly brushed under the table by Pete Shirley&#x27;s books. In this assignment, you will redesign your renderer to make the Monte Carlo component explicit. This will allow you to implement much more powerful rendering techniques in the future.</p><p>This assignment consists of three parts. In the first, you will implement sampling routines for different distributions on the sphere. Then you will get to implement Monte Carlo sampling techniques for your existing materials. Finally, you will implement <em>integrators</em> that will allow you to render your scene with different rendering algorithms.</p><section id="sampling-distributions"><h2><a href="#sampling-distributions">Task 1: Sampling distributions</a></h2><p><span class="m-label m-primary m-flat">3 pts</span></p><p>In this task, you will start with the basics of generating points on the sphere that have specific distributions. We recommend you read <a href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html"><em>Ray Tracing: The Rest of Your Life</em></a>, Chapters <a href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#overview">1</a>-<a href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#generatingrandomdirections">7</a>, before you start.</p><p>To help you get a feel for what these different distributions look like, we want you to generate 3D visualizations of your point sets. For each of the distributions you will implement, write out a list of points to a text file and make a 3D scatter plot of the points. You can do this in Matlab or your favorite plotting software, or in one of many online plotting tools.</p><p>If you look at <code>include/darts/sampling.h</code>, you can see that we already provide you with two functions for generating points in a circle and points in a sphere. These are generated using rejection sampling as described in Pete Shirley&#x27;s books. To help you get started setting up your plotting tools, generate a few hundred points using <code>random_in_unit_sphere()</code> and visualize them in your plotting tool. For reference, we will show you images of our points sets, which we generated by writing out a CSV file from C++ and rendering them using <a href="https://chart-studio.plot.ly/create/#/">plot.ly</a> (click on &quot;import&quot; to upload a CSV, and click on +Trace, type-&gt;3D Scatter to get a scatter plot). If you are familiar with Jupyter notebooks, we also include a short Python Jupyter notebook <code>plot_csv.ipynb</code> for convenience which allows you to do the same thing as the plot.ly website, but on your local computer with Python.</p><p>We generated the CSV by adding a new program in darts called <code>point_gen</code> with the following source code:</p><pre class="m-code"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;darts/common.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;darts/sampling.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;x,y,z</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;0,0,0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Vec3f</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">random_in_unit_sphere</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">fmt</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;{},{},{}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">z</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>To compile this new program, type your source code in a new&nbsp;<code>.cpp</code> file (we called it&nbsp;<code>point_gen.cpp</code>) and modify the&nbsp;main <code>CMakeLists.txt</code> file to tell your compiler about your new executable:</p><pre class="m-code"><span class="nb">add_executable</span><span class="p">(</span><span class="s">point_gen</span> <span class="s">src/point_gen.cpp</span><span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">point_gen</span> <span class="s">PRIVATE</span> <span class="s">darts_lib</span><span class="p">)</span></pre><p>You can then run this program from the terminal as before.</p><aside class="m-block m-primary"><h3>Hint</h3><p>You can type <code>build/point_gen &gt; points.csv</code> in the terminal to directly save the output of the program into a CSV file.</p></aside><div class="m-col-s-6 m-col-m-5 m-right-s"><img class="m-image" src="points-in-sphere.png" alt="Image" /></div><p>If you implemented everything correctly, your program should generate a point distribution like the one on the right.</p><p>This is only for inspiration: You don&#x27;t have to do it this way, and are free to visualize your points in any way you want. Your output will differ depending on which plotting software you use, how many points you output and so forth, but it should look like uniform points within a sphere.</p><section id="autotoc_md73"><h3><a href="#autotoc_md73">Avoiding rejection sampling</a></h3><p>While rejection sampling technique will work, there are a couple issues with this design that will make it harder as we try to implement more sophisticated rendering technique. Firstly, rejection sampling is generally undesirable since it can require an unknown amount of random numbers. The more serious problem is that this rejection sampling relies on <code>randf()</code> which is a global random number generator. Using a single global random number generator is a <em>Very Bad Idea®</em> if we have ambitions to ever introduce thread-level parallelism to our code (to render images more quickly by allowing the multiple cores on a single computer to trace the rays for different pixels simultaneously).</p><p>For these reasons, typical Monte Carlo renderers operate by creating a different random number generator per thread to provide each with its own endless stream of uniform random numbers. We&#x27;ll do this part later on in this assignment. First, however, we&#x27;ll move away from rejection sampling and instead sample each spherical distribution we are interested in using just a fixed and small number of uniform random numbers (typically 2).</p><p>We&#x27;ll do this by implementing a number of functions of the form</p><pre class="m-code"><span class="n">Vec3f</span><span class="w"> </span><span class="n">sample_</span><span class="o">&lt;</span><span class="n">distribution</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vec2f</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">rv</span><span class="p">);</span><span class="w"></span></pre><p>Each of these functions is a warp that takes a random variable <code>rv</code> uniformly distributed in the unit square [0,1)<sup>2</sup> domain and warps it to the desired distribution.</p><p>For each of these functions, we will also implement a corresponding</p><pre class="m-code"><span class="kt">float</span><span class="w"> </span><span class="n">sample_</span><span class="o">&lt;</span><span class="n">distribution</span><span class="o">&gt;</span><span class="n">_pdf</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vec3f</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span></pre><p>function that returns the PDF that the given direction <code>v</code> was sampled.</p><p>We already provide you with an example for a disk: <code>sample_disk()</code> and <code>sample_disk_pdf()</code>.</p><div class="m-clearfix-s"></div><div class="m-clearfix-m"></div><div class="m-clearfix-l"></div></section><section id="autotoc_md74"><h3><a href="#autotoc_md74">Uniform points on the sphere</a></h3><div class="m-col-s-6 m-col-m-5 m-left-s"><img class="m-image" src="points-on-sphere.png" alt="Image" /></div><p>In <code>include/darts/sampling.h</code>, implement the function <code>sample_sphere()</code> that generates points&nbsp;<em>on</em> the sphere instead of its interior. You can begin by simply calling&nbsp;<code>random_in_unit_sphere()</code> and normalizing the result: That will project all points to the surface of the sphere, and give you a result like the one shown in the image.</p><p>While this gives you the distribution you want, we want to avoid rejection sampling and its use of <code>randf()</code>. <a href="http://mathworld.wolfram.com/SpherePointPicking.html">WolframAlpha</a> shows several ways to do this. The easiest is the trigonometric way, for which we give pseudocode below:</p><pre class="m-code"><span class="n">phi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*&lt;</span><span class="n">uniform</span><span class="w"> </span><span class="n">random</span><span class="w"> </span><span class="n">number</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="n">cos_theta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">*&lt;</span><span class="n">uniform</span><span class="w"> </span><span class="n">random</span><span class="w"> </span><span class="n">number</span><span class="o">&gt;</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">sin_theta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">cos_theta</span><span class="o">*</span><span class="n">cos_theta</span><span class="p">);</span><span class="w"></span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin_theta</span><span class="p">;</span><span class="w"></span>
<span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin_theta</span><span class="p">;</span><span class="w"></span>
<span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos_theta</span><span class="p">;</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">vector</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">);</span><span class="w"></span></pre><p>This requires two uniform random numbers. Instead of using <code>randf()</code>, you can instead use the provided uniform random variable <code>rv</code>, which contains both an x and a y component, each of which is a uniform random number. Note also that we provide a convenience function <code>sincos</code> in <code><a href="common_8h.html" class="m-doc">common.h</a></code> which computes and returns both the sin and cos of an angle, and can sometimes lead to more optimized code.</p><p>Also implement the corresponding <code>sample_sphere_pdf()</code> function. The samples are generated uniformly over the sphere, so this function should just return a constant value. But what value? To figure this out, remember that a PDF must integrate to 1 over the entire domain.</p><p>After you implement the functions without rejection sampling, rerun it and visualize the point set. It should give you the same distribution as before, except now you don&#x27;t rely on rejection sampling.</p></section><section id="autotoc_md75"><h3><a href="#autotoc_md75">Uniform points on the hemisphere</a></h3><div class="m-col-s-6 m-col-m-5 m-right-s"><img class="m-image" src="points-on-hemisphere.png" alt="Image" /></div><p>Implement the function&nbsp;<code>sample_hemisphere()</code> (and the corresponding <code>sample_hemisphere_pdf()</code>) to generate points on the hemisphere (i.e. the parts of the sphere with positive z coordinated) instead of the full sphere. Hint: you can achieve this by modifying the way&nbsp;<code>cos_theta</code> is computed in the previous code for sampling the sphere to only produce positive z values.</p><div class="m-clearfix-s"></div><div class="m-clearfix-m"></div><div class="m-clearfix-l"></div></section><section id="autotoc_md76"><h3><a href="#autotoc_md76">Cosine-weighted points on the hemisphere</a></h3><div class="m-col-s-6 m-col-m-5 m-left-s"><img class="m-image" src="points-on-cosine-hemisphere.png" alt="Image" /></div><p>Implement the function&nbsp;<code>sample_hemisphere_cosine()</code> (and the corresponding <code>sample_hemisphere_cosine_pdf()</code>). This function should generate points so that the PDF of the points is proportional to the cosine of the angle between the point and the z-axis.&nbsp;You can again achieve this by modifying the way you compute <code>cos_theta</code> in the previous functions: <code>cos_theta = sqrt(&lt;uniform random value&gt;)</code>. This should give you a distribution like on the right.</p><div class="m-clearfix-s"></div><div class="m-clearfix-m"></div><div class="m-clearfix-l"></div></section><section id="autotoc_md77"><h3><a href="#autotoc_md77">Cosine-power-weighted points on the hemisphere</a></h3><p>Add a new function called&nbsp;<code>sample_hemisphere_cosine_power(float exponent)</code> (and the corresponding <code>sample_hemisphere_cosine_power_pdf()</code>). This function should generate points so that the PDF of the points is proportional to the cosine of the angle between the point and the z-axis, <em>raised to the power of</em> some exponent. For an exponent of 1, we should get standard cosine-weighted hemisphere sampling; for an exponent of 0, we should get the uniform hemisphere, and the distribution should get more and more clustered around (0, 0, 1) for higher and higher exponents.</p><div class="m-col-s-6 m-col-m-5 m-right-s"><img class="m-image" src="points-on-cosine-power-hemisphere.png" alt="Image" /></div><p>Yet again, you can achieve this by modifying the way you compute <code>cos_theta</code> in the above code. Change it to <code>cos_theta = powf(&lt;uniform random number&gt;, 1/(exponent + 1))</code>.</p><p>Try to insert <code>exponent=0</code> and <code>exponent=1</code> into the above equation. Does it do what we want it to do?</p><p>Write out a point set for <code>exponent=20</code>. This should give you a distribution like this:</p><p>Note how clustered the points are around the z-axis.</p><div class="m-clearfix-s"></div><div class="m-clearfix-m"></div><div class="m-clearfix-l"></div></section></section><section id="autotoc_md78"><h2><a href="#autotoc_md78">Task 2: Sampling materials</a></h2><p><span class="m-label m-primary m-flat">4 pts</span></p><p>In this task, you will redesign your <code>Material</code> class to support three new queries. The first of these is&nbsp;<code>Material::eval()</code>: This method will evaluate how much light flows between a given incoming and outgoing ray direction. This method entirely determines what the material will look like.</p><p>The other two queries are needed for rendering materials using Monte Carlo. The&nbsp;<code>Material::sample()</code> method takes an incoming ray direction and samples an outgoing ray direction.&nbsp;The&nbsp;<code>Material::pdf()</code> function returns the probability density of the ray directions produced by&nbsp;<code>Material::sample()</code>.&nbsp;These two queries need to be exactly matched to each other - i.e. <code>Material::pdf()</code> should actually be the exact distribution of samples coming out of&nbsp;<code>Material::sample()</code> – but they do not have to match the shape of the material reflectance exactly (i.e. <code>Material::pdf()</code> does not have to match <code>Material::eval()</code>). It helps if it does – you will have less noise that way — but it does not have to. This allows you to render materials that cannot be sampled exactly. This is a big departure from Peter Shirley&#x27;s books, in which it is implicitly assumed that the sampling method matches the material reflectance exactly, and changing the <code>Material::scatter()</code> method would change both the sampling strategy and the appearance of the material.</p><p>Begin by adding new virtual methods for each of the three queries to the <code>Material</code> base class in&nbsp;<code>include/darts/material.h</code>. You can design these any way you would like, but to help you get started, we give you the interfaces we use in our code for inspiration:</p><pre class="m-code"><span class="cm">/*</span>
<span class="cm">    Evaluate the material response for the given pair of directions.</span>

<span class="cm">    For non-specular materials, this should be the BSDF multiplied by the</span>
<span class="cm">    cosine foreshortening term.</span>

<span class="cm">    Specular contributions should be excluded.</span>

<span class="cm">    \param  wi         The incoming ray direction</span>
<span class="cm">    \param  scattered  The outgoing ray direction</span>
<span class="cm">    \param  hit        The shading hit point</span>
<span class="cm">    \return Color3f    The evaluated color</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">virtual</span><span class="w"> </span><span class="n">Color3f</span><span class="w"> </span><span class="nf">eval</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vec3f</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Vec3f</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scattered</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">HitInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hit</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Color3f</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">    Sample a scattered direction at the surface hitpoint \p hit.</span>

<span class="cm">    If it is not possible to evaluate the pdf of the material (e.g.\ it is</span>
<span class="cm">    specular or unknown), then set \c srec.is_specular to true, and populate</span>
<span class="cm">    \c srec.wo and \c srec.attenuation just like we did previously in the</span>
<span class="cm">    #scatter() function. This allows you to fall back to the way we did</span>
<span class="cm">    things with the #scatter() function, i.e.\ bypassing #pdf()</span>
<span class="cm">    evaluations needed for explicit Monte Carlo integration in your</span>
<span class="cm">    #Integrator, but this also precludes the use of MIS or mixture sampling</span>
<span class="cm">    since the pdf is unknown.</span>

<span class="cm">    \param  wi     The incoming ray direction</span>
<span class="cm">    \param  hit    The incoming ray&#39;s intersection with the surface</span>
<span class="cm">    \param  srec   Populate \p srec.wo, \p srec.is_specular, and \p srec.attenuation</span>
<span class="cm">    \param  rv     Two random variables in [0,1) to use when generating the sample</span>
<span class="cm">    \return bool   True if the surface scatters light</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">sample</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vec3f</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">HitInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hit</span><span class="p">,</span><span class="w"> </span><span class="n">ScatterRecord</span><span class="w"> </span><span class="o">&amp;</span><span class="n">srec</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Vec2f</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rv</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm">    Compute the probability density that #sample() will generate \c scattered (given \c wi).</span>

<span class="cm">    \param  wi         The incoming ray direction</span>
<span class="cm">    \param  scattered  The outgoing ray direction</span>
<span class="cm">    \param  hit        The shading hit point</span>
<span class="cm">    \return float      A probability density value in solid angle measure around \c hit.p.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nf">pdf</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vec3f</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wi</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Vec3f</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scattered</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">HitInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hit</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>You can see that&nbsp;<code>Material::sample()</code> does not return the scattered direction, but instead fills out a&nbsp;<code>ScatterRecord</code> structure. Our structure looks as follows:</p><pre class="m-code"><span class="k">struct</span> <span class="nc">ScatterRecord</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Color3f</span><span class="w"> </span><span class="n">attenuation</span><span class="p">;</span><span class="w">         </span><span class="c1">// Attenuation to apply to the traced ray</span>
<span class="w">    </span><span class="n">Vec3f</span><span class="w">   </span><span class="n">wo</span><span class="p">;</span><span class="w">                  </span><span class="c1">// The sampled outgoing direction</span>
<span class="w">    </span><span class="kt">bool</span><span class="w">    </span><span class="n">is_specular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Flag indicating whether the ray has a degenerate PDF</span>
<span class="p">};</span><span class="w"></span></pre><p>This might look strange: In theory, all that&nbsp;<code>Material::sample()</code> needs to generate is a scattered direction. However, there are two additional fields:&nbsp;<code>ScatterRecord::attenuation</code> and&nbsp;<code>ScatterRecord::is_specular</code>. The reason for this is that certain materials (like mirrors or glass) do not have real PDFs, or have PDFs that are very difficult to compute (like Peter Shirley&#x27;s&nbsp;metal material).</p><p>For now, implement the&nbsp;<code>Material::sample()</code> method for all your existing materials and make it a)&nbsp;set <code>ScatterRecord::is_specular</code> to true &ndash; signaling to the rest of the code that this material does not have a PDF and we should fall back to the non-Monte Carlo way of computing colors, and b) fill out <code>ScatterRecord::wo</code> and&nbsp;<code>ScatterRecord::attenuation</code> by doing something just like in the <code>Material::scatter()</code> method (though without rejection sampling or the global <code>randf()</code>). This fallback will make sure your existing materials are backwards compatible. In the following tasks, you will slowly replace the fallback with real sampling code and PDFs.</p><section id="autotoc_md79"><h3><a href="#autotoc_md79">Lambertian sampling</a></h3><p>The formula for the Lambertian material is extremely simple: It only depends on the normal and the scattered direction, and does not take the incoming direction into account. In pseudo-code, it is <code>albedo * max(0, dot(scattered_dir, normal))/pi</code>. Implement this as the&nbsp;<code>Lambertian::eval()</code> method.</p><p>The PDF of a <code>Lambertian</code> material is even simpler: It is <code>max(0, dot(scattered_dir, normal))/pi</code>. Implement this as the&nbsp;<code>Lambertian::pdf()</code> method.</p><p>The only remaining problem is to sample this PDF. However, you already implemented the bulk of the sampling code in <a href="#sampling-distributions">Task 1</a>, when you implemented <code>sample_hemisphere_cosine()</code>. All you need to do is to modify the <code>Lambertian::sample()</code> method to set&nbsp;<code>srec.wo</code> to the random cosine-weighted direction. Since you now have proper sampling code, remember to set <code>is_specular</code> to false!</p></section><section id="autotoc_md80"><h3><a href="#autotoc_md80">Testing your code</a></h3><p>Testing sampling code can be notoriously difficult. To help you with this, we wrote a small sample testing feature into darts. When run in this mode, instead of rendering a scene, darts will run your sampling code and output statistics to help you decide whether your implementation is correct or not. The implementation is available in <code>include/darts/test.h</code> and the file(s) in <code>src/tests/</code>. Add these to your <code>CMakeLists.txt</code> file. This should compile the tests and make them available, but we still need to run them. In <code>src/darts.cpp</code>, add <code>#include &lt;darts/test.h&gt;</code> to the top and then call the function <code>run_tests()</code> right before the line containing <code>auto scene = make_shared&lt;Scene&gt;(j);</code>.</p><p>Note that this code assumes you use the same sampling interface as we use – if you made changes, you might have to adapt the tool.</p><p>Once you get the new code compiled, run <code>darts scenes/assignment4/test_materials.json</code>.</p><p>The tester will do two things: First, it will evaluate <code>Material::pdf()</code> over the sphere and output its integral. This integral should be close to 1 (otherwise, it is not a PDF). You should see an output like:</p><pre class="m-code">Integral of PDF (should be close to 1): 1.00003</pre><p>Second, the code will call&nbsp;<code>Material::sample()</code> many times and build a histogram of the sampled directions. This histogram should exactly match the PDF. The tester will output two images,&nbsp;<code>lambertian-pdf.png</code> (the PDF) and&nbsp;<code>lambertian-sampled.png</code> (the histogram). These should match with each other and look similar to this:</p><div class="twentytwenty-container"><img class="m-image" src="lambertian-pdf.png" alt="Image" />
 <img class="m-image" src="lambertian-sampled.png" alt="Image" /></div><p>Additionally, your sample method should return successfully and not generate invalid directions; the code will test for that and output a statement like</p><pre class="m-code">100% of samples were valid (this should be close to 100%)</pre><p>Make sure your code passes the tests before proceeding. If you have any problems, make sure you normalize the directions that are passed into your code – sometimes the <code>scattered</code>/<code>dir_in</code> directions might not have unit length, which will make your code misbehave.</p></section><section id="autotoc_md81"><h3><a href="#autotoc_md81">Oriented samples</a></h3><p>So far, your Lambertian sampling code has a big problem: It assumes the normal is (0, 0, 1). This makes the sampling algorithm simpler, but – of course – most of the time, the surface normal will not be (0, 0, 1).</p><p>To fix this, read <a href="https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#orthonormalbases">Chapter 8</a> of the text book and implement an <em>ONB</em> (Ortho-Normal Basis) class. This will allow you to rotate directions for arbitrary normals. Modify your <code>Material::sample()</code> code to transform the sampled direction from <code>sample_hemisphere_cosine()</code> using the ONB, oriented to the surface normal. You can look at Peter Shirley&#x27;s code for inspiration.</p><p>You can test your code using the <code>&quot;rotated-lambertian&quot;</code> test in the sample test scene. You should get images like these:</p><div class="twentytwenty-container"><img class="m-image" src="rotated-lambertian-pdf.png" alt="Image" />
 <img class="m-image" src="rotated-lambertian-sampled.png" alt="Image" /></div></section><section id="autotoc_md82"><h3><a href="#autotoc_md82">Phong material</a></h3><p>Next to Lambert, the Phong reflection model is one of the earliest and simplest in computer graphics. It tries to model glossy reflections, such as from rough metal or plastic. Start by adding a new material class in <code>src/materials/phong.cpp</code> called <code>Phong</code>.</p><p>To allow our JSON parser to recognize this new type of Material, we need to inform it how to create a <code>Phong</code> material and which type string (<code>&quot;phong&quot;</code>) to associate with it. Calling the following macro at the bottom of <code>src/materials/phong.cpp</code> will accomplish what we want:</p><pre class="m-code"><span class="n">DARTS_REGISTER_CLASS_IN_FACTORY</span><span class="p">(</span><span class="n">Material</span><span class="p">,</span><span class="w"> </span><span class="n">Phong</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;phong&quot;</span><span class="p">)</span><span class="w"></span></pre><p>For a perfect mirror material (such as polished metal), all light scatters into the mirror direction, i.e. the incoming ray reflected by the normal. The <code>Phong</code> material tries to approximate surface roughness by &quot;blurring&quot; the reflection direction about the perfect mirror direction. The amount of spread can be controlled by a parameter to model different amounts of roughness of the surface. In the <code>Phong</code> material, this spread is called the&nbsp;<code>exponent</code>. Add an&nbsp;<code>exponent</code> member to your <code>Phong</code> class, and get it from JSON in the <code>Phong</code> constructor.</p><p>The PDF of the <code>Phong</code> material looks like this (pseudocode):</p><pre class="m-code"><span class="n">mirror_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">reflect</span><span class="p">(</span><span class="n">dir_in</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="p">));</span><span class="w"></span>
<span class="n">cosine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">scattered</span><span class="p">),</span><span class="w"> </span><span class="n">mirror_dir</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">constant</span><span class="o">*</span><span class="nf">powf</span><span class="p">(</span><span class="n">cosine</span><span class="p">,</span><span class="w"> </span><span class="n">exponent</span><span class="p">);</span><span class="w"></span></pre><p>It measures the cosine of the angle between the scattered direction and the perfect mirror direction. The cosine is then raised to a power. For low exponents, there is a wide spread of this PDF around the mirror direction; for large exponents, the PDF becomes more and more concentrated around the mirror direction. <code>constant</code> is a normalization constant to make sure the PDF integrates to 1. It is computed like this: <code class="m-code"><span class="n">constant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">exponent</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="w"></span></code>.</p><p>The result of <code>Phong::eval()</code> is simply the PDF multiplied by the albedo.</p><p>Sampling this material follows in two steps:</p><p>First, you need to generate directions from a distribution proportional to a cosine raised to a power (Hint: You already implemented this; it is <code>sample_hemisphere_cosine_power(exponent)</code>). Second, you need to orient those samples so they are centered on the mirror direction (Hint: Use your <code>ONB</code> class, centered on the reflected incoming direction). Note that this can generate directions below the hemisphere, so make sure to reject those (i.e. return false in <code>Phong::sample()</code>)!</p><p>You can test your code using the <code>&quot;phong&quot;</code> and <code>&quot;rotated-phong&quot;</code> tests in the sample test tool. You should get images like these:</p><div class="twentytwenty-container"><img class="m-image" src="phong-pdf.png" alt="Image" />
 <img class="m-image" src="phong-sampled.png" alt="Image" />
 <img class="m-image" src="rotated-phong-pdf.png" alt="Image" />
 <img class="m-image" src="rotated-phong-sampled.png" alt="Image" /></div></section><section id="autotoc_md83"><h3><a href="#autotoc_md83">Grad students only: Blinn-Phong</a></h3><p>If you are a grad student, you will also need to implement the&nbsp;<em>Blinn-Phong</em> shading model, which is a slightly more realistic variation on the standard Phong model. In Blinn-Phong, we first generate a <em>random normal</em>, and then treat that normal as the surface normal for reflecting the incoming direction. Similar to Phong, this will create random directions distributed around the mirror direction, but with a different shape. Begin by creating a new&nbsp;<code>BlinnPhong</code> material that also has an&nbsp;<code>exponent</code> parameter, just like Phong. Use our <code>DARTS_REGISTER_CLASS_IN_FACTORY</code> macro to create this new material for the <code>&quot;blinn_phong&quot;</code> key.</p><p>The easiest method to implement is the&nbsp;<code>BlinnPhong::sample()</code> method, which we will start with. It should use&nbsp;<code>sample_hemisphere_cosine_power()</code> and your <code>ONB</code> class to generate a cosine-power weighted direction centered on the surface normal. Use this new, random direction to reflect the incoming ray (as if the random direction was the real surface normal). Note that this can generate directions below the hemisphere, so make sure to reject those (i.e. return false in <code>BlinnPhong::sample()</code>)!</p><p>The PDF method will be slightly more complicated. You first need to figure out which random normal would reflect the (given) incoming ray so that it matches the scattered ray. You can use the fact that the normal must lie exactly halfway between the incoming and scattered direction:</p><pre class="m-code"><span class="n">random_normal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">normalize</span><span class="p">(</span><span class="n">dir_in</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">scattered</span><span class="p">))</span><span class="w"></span></pre><p>Then, you need to compute the PDF of generating this random normal. Since we generated this from a cosine-power distribution, this must be the cosine-power PDF:</p><pre class="m-code"><span class="n">cosine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">random_normal</span><span class="p">,</span><span class="w"> </span><span class="n">real_normal</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">normal_pdf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">exponent</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">powf</span><span class="p">(</span><span class="n">cosine</span><span class="p">,</span><span class="w"> </span><span class="n">exponent</span><span class="p">);</span><span class="w"></span></pre><p>Finally, we need to account for a warping of the PDF by the reflection operation. The final PDF becomes:</p><pre class="m-code"><span class="n">final_pdf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normal_pdf</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">dir_in</span><span class="p">,</span><span class="w"> </span><span class="n">random_normal</span><span class="p">))</span><span class="w"></span></pre><p>The&nbsp;<code>BlinnPhong::eval()</code> method is simply the PDF method times the albedo.</p><p>You can test your implementation using the sample tester tool. You should get images like these:</p><div class="twentytwenty-container"><img class="m-image" src="blinn_phong-pdf.png" alt="Image" />
 <img class="m-image" src="blinn_phong-sampled.png" alt="Image" />
 <img class="m-image" src="rotated-blinn_phong-pdf.png" alt="Image" />
 <img class="m-image" src="rotated-blinn_phong-sampled.png" alt="Image" /></div><aside class="m-block m-success"><h3>Hint</h3><p>Not all Blinn-Phong directions make sense. If the incoming or scattered directions are below the hemisphere, the PDF should be zero.</p></aside>&nbsp;<aside class="m-block m-danger"><h3>Warning</h3><p>Sampling Blinn-Phong can generate quite a few directions below the hemisphere. Your valid sample count might go as low as 90%, and the integral of your PDF might go as low as 0.9.</p></aside></section></section><section id="autotoc_md84"><h2><a href="#autotoc_md84">Task 3: Samplers</a></h2><p>As mentioned previously, one of our goals is to move away from using the global random number generator in <code>randf()</code>, and instead create an explicit random number generator (it then becomes much easier to parallelize our code where each thread maintains its own random number generator). In rendering we typically call this abstraction a <code>Sampler</code> instead of a random number generator, partially because it produces <em>samples</em> for the Monte Carlo algorithm, but also because we can create Samplers that don&#x27;t actually produce pseudo-random numbers at all, but rather carefully crafted deterministic samples that can often compute lower noise images more quickly.</p><p>We provide a base class for all Samplers in <code>include/darts/sampler.h</code>, as well as a default example Sampler in <code>src/samplers/independent.cpp</code> which just generates independent random samples. Go read the implementation and comments in these two files to get an overview. You&#x27;ll notice that we use our <code>DartsFactory</code> mechanism and the <code>DARTS_REGISTER_CLASS_IN_FACTORY</code> macro to allow the scene to specify a specific sampler type by name. We won&#x27;t be implementing different types of Samplers in this assignment, but you now have a nice framework to explore this for your final project if you want.</p><p>We do need to introduce a small change to our parser to make this work. First, add a new member variable to <code>Scene</code> in <code>include/darts/scene.h</code>: <code>shared_ptr&lt;Sampler&gt; m_sampler;</code>. Then, where we currently have a block of code in <code>Scene::parse()</code> that starts with:</p><pre class="m-code"><span class="c1">//</span>
<span class="c1">// read number of samples to take per pixel</span>
<span class="c1">//</span>
<span class="p">...</span><span class="w"></span></pre><p>you&#x27;ll need to replace it with something like:</p><pre class="m-code"><span class="c1">//</span>
<span class="c1">// parse the sampler</span>
<span class="c1">//</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s">&quot;sampler&quot;</span><span class="p">))</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">json</span><span class="w"> </span><span class="n">j2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">[</span><span class="s">&quot;sampler&quot;</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">j2</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">spdlog</span><span class="o">::</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;No sampler &#39;type&#39; specified, assuming independent sampling.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">j2</span><span class="p">[</span><span class="s">&quot;type&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;independent&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">m_sampler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DartsFactory</span><span class="o">&lt;</span><span class="n">Sampler</span><span class="o">&gt;::</span><span class="n">create</span><span class="p">(</span><span class="n">j2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">else</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">spdlog</span><span class="o">::</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;No sampler specified, defaulting to 1 spp independent sampling.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">m_sampler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DartsFactory</span><span class="o">&lt;</span><span class="n">Sampler</span><span class="o">&gt;::</span><span class="n">create</span><span class="p">({{</span><span class="s">&quot;type&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;independent&quot;</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;samples&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}});</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>This allows our code to be backwards compatible with our previous scene files which have no concept of a Sampler, while allowing you to explore different samplers in the future.</p></section><section id="autotoc_md85"><h2><a href="#autotoc_md85">Task 4: Integrators</a></h2><p><span class="m-label m-primary m-flat">4 pts</span></p><p>In this task, you will extend your renderer to support different&nbsp;<em>integrators.</em> In computer graphics, we say &quot;integrator&quot; to refer to an algorithm for rendering an image. So far, we have been using the algorithm outlined in Peter Shirley&#x27;s books, but there are more powerful (and less noisy) integrators out there, and you will implement the ability to select different integrators in this task.</p><p>Begin by creating an <code>Integrator</code> base class (you could do this in a new header file called <code>include/darts/integrator.h</code>. This class should have a method for returning the color along a particular ray similar to <code>Scene::recursive_color()</code> that we used in previous assignments. You can call this method what you would like, but we named it <code>Integrator::Li()</code> for &quot;Incoming radiance&quot; or &quot;light, incoming&quot;. You can add parameters to this method as you see fit, but it will need access to our recently introduced Sampler. For inspiration, this is what our method looks like:</p><pre class="m-code"><span class="cm">/*</span>
<span class="cm">    Sample the incident radiance along a ray</span>

<span class="cm">    \param scene    The underlying scene</span>
<span class="cm">    \param sampler  A sample generator</span>
<span class="cm">    \param ray      The ray to trace</span>
<span class="cm">    \return         An estimate of the radiance in this direction</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">virtual</span><span class="w"> </span><span class="n">Color3f</span><span class="w"> </span><span class="nf">Li</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Scene</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scene</span><span class="p">,</span><span class="w"> </span><span class="n">Sampler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sampler</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Ray3f</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ray</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The default integrator just returns magenta</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Color3f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><section id="autotoc_md86"><h3><a href="#autotoc_md86">Normal integrator</a></h3><p>To test your new integrator class, create a test integrator class called <code>NormalsIntegrator</code> that inherits from <code>Integrator</code> and simply renders the normals of the visible geometry in the scene. In <code>NormalsIntegrator::Li()</code>, call <code>scene.intersect()</code> to intersect the scene along the ray passed to <code>Li</code> and, if you hit something, return the <em>absolute</em> value of the shading normal as the output color. If you do not hit anything, return black. Since we will ultimately support many different types of integrators, we organized our new source file under <code>src/integrators/normals.cpp</code>.</p><p>Now that we have a test integrator, we need to do some plumbing to make the scene use our new integrator interface. In the <code>Scene</code> class (in <code>include/darts/scene.h</code>), add a <code>shared_ptr&lt;Integrator&gt; m_integrator;</code> field. This will contain the integrator used for rendering the image. Go to <code>scene.cpp</code> and change <code>Scene::raytrace()</code> to call <code>m_integrator-&gt;Li(*this, ...)</code> instead of <code>Scene::recursive_color()</code>. To remain backwards compatible with scenes files that don&#x27;t specify an integrator, you could first check if <code>m_integrator</code> is null, and use the old <code>Scene::recursive_color()</code> if it is.</p><p>Now let&#x27;s add the ability to set the integrator from JSON. In <code>parser.cpp</code>, go to <code>Scene::parse()</code>. Take inspiration from the way <code>Scene::parse()</code> sets the accelerator of the scene. Add some code that checks for an <code>&quot;integrator&quot;</code> field and sets the <code>m_integrator</code> member of the scene. We want to support many different kinds of integrators, so we&#x27;ll use the <code>DartsFactory&lt;Integrator&gt;::create()</code> function that uses the <code>&quot;type&quot;</code> field of the JSON object to automatically create the appropriate integrator.</p><p>To make this work, we also need to inform the <code>DartsFactory</code> how to create the new integrator and which type (<code>&quot;normals&quot;</code>) to associate with it. To do this, add the following macro at the bottom of <code>src/integrators/normals.cpp</code>:</p><pre class="m-code"><span class="n">DARTS_REGISTER_CLASS_IN_FACTORY</span><span class="p">(</span><span class="n">Integrator</span><span class="p">,</span><span class="w"> </span><span class="n">NormalsIntegrator</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;normals&quot;</span><span class="p">)</span><span class="w"></span></pre><p>You can now test your implementation by running it on <code>scenes/assignment4/ajax-normals.json</code>. If everything works correctly, you should get an image like this:</p><div class="m-col-s-8 m-col-m-8, m-col-l-7 m-center-s"><a href="ajax-normals-ref.png"><img class="m-image" src="ajax-normals-ref.png" alt="Image" /></a></div></section><section id="autotoc_md87"><h3><a href="#autotoc_md87">Ambient occlusion integrator</a></h3><p>Now that the machinery for different integrators is in place, we can start creating more interesting integrators. Create a new <code>AmbientOcclusionIntegrator</code> class that will generate an <em>ambient occlusion</em> image.</p><p>Ambient occlusion is a rendering technique which assumes that a (diffuse) surface receives uniform illumination from all directions (similar to the conditions inside a <a href="https://en.wikipedia.org/wiki/Lightbox#/media/File:DIY_Lightbox.jpg">light box</a>), and that visibility is the only effect that matters. Some surface positions will receive less light than others since they are occluded, hence they will look darker.</p><p>Implementing ambient occlusion is very simple: In your integrator&#x27;s <code>Li</code> method, first find the intersection along the passed in camera ray. If the ray misses the scene, return black; if it hits a surface, sample the material at that point (use your new sample method for this). Now, construct a new &quot;shadow&quot; ray starting at the hit location going in the scattered direction, and check if it intersects something. If this new ray does not intersect anything, it means this ray sees the white &quot;sky&quot;: Return white in this case. If the ray hits something, the sky is occluded, and you should return black instead. We put our implementation in <code>src/integrators/ao.cpp</code>.</p><p>Make sure to register the new integrator with the <code>DartsFactory</code> by adding</p><pre class="m-code"><span class="n">DARTS_REGISTER_CLASS_IN_FACTORY</span><span class="p">(</span><span class="n">Integrator</span><span class="p">,</span><span class="w"> </span><span class="n">AmbientOcclusionIntegrator</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ao&quot;</span><span class="p">)</span><span class="w"></span></pre><p>to the bottom of your implementation file. Because we rely on the <code>DartsFactory</code> in the parser, it should now automatically create either a normals integrator or an ambient occlusion integrator, depending on the <code>&quot;type&quot;</code> field of the <code>&quot;integrator&quot;</code> JSON object in the scene file.</p><p>You can test your implementation by running it on <code>scenes/assignment4/ajax-ao.json</code>. If everything works correctly, you should get an image like this:</p><div class="m-col-s-8 m-col-m-8, m-col-l-7 m-center-s"><a href="ajax-ao-ref.png"><img class="m-image" src="ajax-ao-ref.png" alt="Image" /></a></div></section><section id="autotoc_md88"><h3><a href="#autotoc_md88">Material sampling integrator</a></h3><p>The algorithm described by Peter Shirley in his books is (secretly) a form of <em>path tracing</em>, which is a rendering algorithm that traces rays exclusively from the camera. The flavor of path tracing you have been implementing in the previous assignments is sometimes called &quot;Kajiya-style path tracing&quot;, after its inventor.</p><p>In this task, you will reimplement this flavor of path tracing as its own integrator, but this time you will make the PDFs and sampling methods that are involved explicit. This will allow you to implement more powerful forms of path tracing in the future.</p><p>Begin by making a new <code>PathTracerMats</code> integrator. We put ours in <code>src/integrators/path_tracer_mats.cpp</code>. This integrator will start from a camera ray and recursively trace new rays by sampling materials. Write your <code>Li</code> method based on the <code>Scene::recursive_color</code> method you wrote in previous assignments. Instead of calling <code>Material::scatter()</code> and multiplying recursive calls by <code>attenuation</code>, call your new <code>Material::sample()</code> method, and multiply recursive calls by <code>Material::eval()</code> and divide by <code>Material::pdf()</code>. Implicitly, that is what Peter Shirley&#x27;s algorithm was already doing: <code>attenuation</code> was <code>eval/pdf</code> in disguise, with factors appearing in both terms already cancelled out.</p><p>The only wrinkle in this is that some materials might not support the PDF interface (such as mirrors/glass or Peter Shirley&#x27;s metal material). You can detect this by checking the <code>is_specular</code> flag; if that is set, multiply by <code>attenuation</code> instead of <code>eval/pdf</code>.</p><p>You can test your implementation by rendering the remaining scenes in <code>scenes/assignment4</code>. We show the results from our implementation below. You can further test your code by re-rendering some of the scenes from previous assignments using your new integrator-based implementation.</p><div class="m-row m-container-inflate"><div class="m-col-s-6"><a href="phong-ref.png"><img class="m-image" src="phong-ref.png" alt="Image" /></a></div><div class="m-col-s-6"><a href="blinn_phong-ref.png"><img class="m-image" src="blinn_phong-ref.png" alt="Image" /></a></div><div class="m-col-s-6"><a href="veach_mats-ref.png"><img class="m-image" src="veach_mats-ref.png" alt="Image" /></a></div><div class="m-col-s-6"><a href="odyssey_mats-ref.png"><img class="m-image" src="odyssey_mats-ref.png" alt="Image" /></a></div><div class="m-col-s-5"><a href="buddha-box-ref.png"><img class="m-image" src="buddha-box-ref.png" alt="Image" /></a></div></div></section></section><section id="autotoc_md89"><h2><a href="#autotoc_md89">What to submit</a></h2><p>In your report, make sure to include:</p><ul><li>Visualized point sets for all distributions from task 1</li><li>Rendered images of all the scenes in <code>scenes/assignment4</code></li></ul><p>Then submit according to the instructions in the <a href="getting-started.html#submitting-on-canvas" class="m-doc">Submitting on Canvas</a> section of <a href="getting-started.html" class="m-doc">Getting started</a> guide.</p></section>
        <div class="m-note m-dim m-thin m-text-center"><a href="assignment3.html" class="m-doc">&laquo; A3: Textures</a> | <a href="assignments.html" class="m-doc">Assignments</a> | <a href="assignment5.html" class="m-doc">A5: Sampling lights &raquo;</a></div>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v1.js"></script>
<script src="searchdata-v1.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>CS
87/287 Rendering Algorithms. Created with <a href="https://doxygen.org/">Doxygen</a> 1.8.17 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
